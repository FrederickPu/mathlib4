/-
Copyright (c) 2022 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.GroupTheory.Subsemigroup.Basic

#align_import group_theory.subsemigroup.membership from "leanprover-community/mathlib"@"6cb77a8eaff0ddd100e87b1591c6d3ad319514ff"

/-!
# Subsemigroups: membership criteria

In this file we prove various facts about membership in a subsemigroup.
The intent is to mimic `GroupTheory/Submonoid/Membership`, but currently this file is mostly a
stub and only provides rudimentary support.

* `mem_iSup_of_directed`, `coe_iSup_of_directed`, `mem_sSup_of_directed_on`,
  `coe_sSup_of_directed_on`: the supremum of a directed collection of subsemigroup is their union.

## TODO

* Define the `FreeSemigroup` generated by a set. This might require some rather substantial
  additions to low-level API. For example, developing the subtype of nonempty lists, then defining
  a product on nonempty lists, powers where the exponent is a positive natural, et cetera.
  Another option would be to define the `FreeSemigroup` as the subsemigroup (pushed to be a
  semigroup) of the `FreeMonoid` consisting of non-identity elements.

## Tags
subsemigroup
-/

variable {ι : Sort*} {M A B : Type*}

section NonAssoc

variable [Mul M]

open Set BundledSet

@[to_additive]
instance : DirectedSetUnionPred M IsSubsemigroup := by rw [isSubsemigroup_eq]; infer_instance

namespace Subsemigroup

#align subsemigroup.mem_supr_of_directed BundledSet.mem_iSup_of_directed'
#align add_subsemigroup.mem_supr_of_directed BundledSet.mem_iSup_of_directed'
#align subsemigroup.coe_supr_of_directed BundledSet.carrier_iSup_of_directed'
#align add_subsemigroup.coe_supr_of_directed BundledSet.carrier_iSup_of_directed'
#align subsemigroup.mem_Sup_of_directed_on BundledSet.mem_sSup_of_directedOn'
#align add_subsemigroup.mem_Sup_of_directed_on BundledSet.mem_sSup_of_directedOn'
#align subsemigroup.coe_Sup_of_directed_on BundledSet.carrier_sSup_of_directedOn'
#align add_subsemigroup.coe_Sup_of_directed_on BundledSet.carrier_sSup_of_directedOn'

#align subsemigroup.mem_sup_left BundledSet.mem_sup_left
#align add_subsemigroup.mem_sup_left BundledSet.mem_sup_left

#align subsemigroup.mem_sup_right BundledSet.mem_sup_right
#align add_subsemigroup.mem_sup_right BundledSet.mem_sup_right

@[to_additive]
theorem mul_mem_sup {p : Set M → Prop} [BundledSet.Implies p IsSubsemigroup] {op} [SupPred M p op]
    {S T : BundledSet M p} {x y : M} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ S ⊔ T :=
  mul_mem (mem_sup_left hx) (mem_sup_right hy)
#align subsemigroup.mul_mem_sup Subsemigroup.mul_mem_sup
#align add_subsemigroup.add_mem_sup AddSubsemigroup.add_mem_sup

#align subsemigroup.mem_supr_of_mem BundledSet.mem_iSup_of_mem
#align add_subsemigroup.mem_supr_of_mem BundledSet.mem_iSup_of_mem
#align subsemigroup.mem_Sup_of_mem BundledSet.mem_sSup_of_mem
#align add_subsemigroup.mem_Sup_of_mem BundledSet.mem_sSup_of_mem

/-- An induction principle for elements of `⨆ i, S i`.
If `C` holds all elements of `S i` for all `i`, and is preserved under multiplication,
then it holds for all elements of the supremum of `S`. -/
@[to_additive (attr := elab_as_elim)
"An induction principle for elements of `⨆ i, S i`. If `C` holds all
elements of `S i` for all `i`, and is preserved under addition, then it holds for all elements of
the supremum of `S`."]
theorem iSup_induction (S : ι → Subsemigroup M) {C : M → Prop} {x₁ : M} (hx₁ : x₁ ∈ ⨆ i, S i)
    (hp : ∀ i, ∀ x₂ ∈ S i, C x₂) (hmul : ∀ x y, C x → C y → C (x * y)) : C x₁ := by
  rw [iSup_eq_closure] at hx₁
  refine' closure_induction hx₁ (fun x₂ hx₂ => _) hmul
  obtain ⟨i, hi⟩ := Set.mem_iUnion.mp hx₂
  exact hp _ _ hi
#align subsemigroup.supr_induction Subsemigroup.iSup_induction
#align add_subsemigroup.supr_induction AddSubsemigroup.iSup_induction

/-- A dependent version of `Subsemigroup.iSup_induction`. -/
@[to_additive (attr := elab_as_elim)
"A dependent version of `AddSubsemigroup.iSup_induction`."]
theorem iSup_induction' (S : ι → Subsemigroup M) {C : ∀ x, (x ∈ ⨆ i, S i) → Prop}
    (hp : ∀ (i) (x) (hxS : x ∈ S i), C x (mem_iSup_of_mem i ‹_›))
    (hmul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x₁ : M}
    (hx₁ : x₁ ∈ ⨆ i, S i) : C x₁ hx₁ := by
  refine Exists.elim ?_ fun (hx₁' : x₁ ∈ ⨆ i, S i) (hc : C x₁ hx₁') => hc
  refine @iSup_induction _ _ _ S (fun x' => ∃ hx'', C x' hx'') _ hx₁
      (fun i x₂ hx₂ => ?_) fun x₃ y => ?_
  · exact ⟨_, hp _ _ hx₂⟩
  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩
    exact ⟨_, hmul _ _ _ _ Cx Cy⟩
#align subsemigroup.supr_induction' Subsemigroup.iSup_induction'
#align add_subsemigroup.supr_induction' AddSubsemigroup.iSup_induction'

end Subsemigroup

end NonAssoc
