/-
Copyright (c) 2024 María Inés de Frutos Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: María Inés de Frutos Fernández, Xavier Généreux
-/
import Mathlib.Algebra.Algebra.Equiv
import Mathlib.Algebra.Algebra.NonUnitalHom
import Mathlib.Algebra.BigOperators.Finsupp
import Mathlib.Algebra.Module.BigOperators
import Mathlib.LinearAlgebra.Finsupp

/-!
# Skew Monoid algebras
This file presents a skewed version of `Mathlib.Algebra.MonoidAlgebra.Basic`.

## Definition
We define `SkewMonoidAlgebra k G := G →₀ k` attached with a skewed convolution product.
Here, the product of two elements `f g : SkewMonoidAlgebra k G` is the finitely supported
function whose value at `a` is the sum of `f x * (x • g y)` over all pairs `x, y`
such that `x * y = a`.

## Implementation notes
The associativity of the skewed multiplication depends on the `[MulSemiringAction G k]` instance.
In particular, this means that unlike in `Mathlib.Algebra.MonoidAlgebra.Basic`, `G` will
need to be a monoid for most of our uses.
-/

noncomputable section

open BigOperators

open Finset

open Finsupp hiding single mapDomain

universe u₁ u₂ u₃ u₄

variable (k : Type u₁) (G : Type u₂) (H : Type*) {R : Type*}

/-! ### Multiplicative monoids -/

section

variable [AddCommMonoid k]

/-- The skew monoid algebra over a semiring `k` generated by the monoid `G`.
It is the type of finite formal `k`-linear combinations of terms of `G`,
endowed with a skewed convolution product.
-/
def SkewMonoidAlgebra : Type max u₁ u₂ := G →₀ k

instance SkewMonoidAlgebra.inhabited : Inhabited (SkewMonoidAlgebra k G) :=
  inferInstanceAs (Inhabited (G →₀ k))

instance SkewMonoidAlgebra.addCommMonoid : AddCommMonoid (SkewMonoidAlgebra k G) :=
  inferInstanceAs (AddCommMonoid (G →₀ k))

instance SkewMonoidAlgebra.instIsCancelAdd [IsCancelAdd k] : IsCancelAdd (SkewMonoidAlgebra k G) :=
  inferInstanceAs (IsCancelAdd (G →₀ k))

instance SkewMonoidAlgebra.coeFun : CoeFun (SkewMonoidAlgebra k G) fun _ => G → k :=
  Finsupp.coeFun

end

namespace SkewMonoidAlgebra

variable {k G}

section

variable [AddCommMonoid k] [NonUnitalNonAssocSemiring R]

/-- `single a b` is the finitely supported function with value `b` at `a` and zero otherwise. -/
abbrev single (a : G) (b : k) : SkewMonoidAlgebra k G := Finsupp.single a b

theorem single_zero (a : G) : (single a 0 : SkewMonoidAlgebra k G) = 0 := Finsupp.single_zero a

theorem single_add (a : G) (b₁ b₂ : k) : single a (b₁ + b₂) = single a b₁ + single a b₂ :=
  Finsupp.single_add a b₁ b₂

@[simp]
theorem sum_single_index {N} [AddCommMonoid N] {a : G} {b : k} {h : G → k → N}
    (h_zero : h a 0 = 0) : (single a b).sum h = h a b :=
  Finsupp.sum_single_index h_zero

@[simp]
theorem sum_single (f : SkewMonoidAlgebra k G) : f.sum single = f := Finsupp.sum_single f

theorem single_apply {a a' : G} {b : k} [Decidable (a = a')] :
    single a b a' = if a = a' then b else 0 :=
  Finsupp.single_apply

@[simp]
theorem single_eq_zero {a : G} {b : k} : single a b = 0 ↔ b = 0 := Finsupp.single_eq_zero

/-- Given `f : α → β` and `v : α →₀ M`, `mapDomain f v : β →₀ M` is the finitely supported function
  whose value at `a : β` is the sum of `v x` over all `x` such that `f x = a`. -/
abbrev mapDomain {G' : Type*} (f : G → G') (v : SkewMonoidAlgebra k G) : SkewMonoidAlgebra k G' :=
  Finsupp.mapDomain f v

theorem mapDomain_sum {k' G' : Type*} [Semiring k'] {f : G → G'} {s : SkewMonoidAlgebra k' G}
    {v : G → k' → SkewMonoidAlgebra k G} :
    mapDomain f (s.sum v) = s.sum fun a b => mapDomain f (v a b) :=
  Finsupp.mapDomain_sum

/-- A non-commutative version of `SkewMonoidAlgebra.lift`: given an additive homomorphism
`f : k →+ R` and a homomorphism `g : G → R`, returns the additive homomorphism from
`SkewMonoidAlgebra k G` such that `liftNC f g (single a b) = f b * g a`.

If `f` is a ring homomorphism and for all `x : R`, `y : G` the equality
`(f (y • x)) * g y = (g y) * (f x))` holds, then the result is a ring homomorphism.

If `R` is a `k`-algebra and `f = algebraMap k R`, then the result is an algebra homomorphism called
`SkewMonoidAlgebra.lift`. -/
def liftNC (f : k →+ R) (g : G → R) : SkewMonoidAlgebra k G →+ R :=
  liftAddHom fun x : G => (AddMonoidHom.mulRight (g x)).comp f

@[simp] theorem liftNC_single (f : k →+ R) (g : G → R) (a : G) (b : k) :
    liftNC f g (single a b) = f b * g a :=
  liftAddHom_apply_single _ _ _

end

section SMul

variable [NonUnitalNonAssocSemiring k] [Mul G] [SMul G k]

/-- The product of `f g : SkewMonoidAlgebra k G` is the finitely supported function whose value
  at `a` is the sum of `f x * (x • g y)` over all pairs `x, y` such that `x * y = a`.
  (Think of a skew group ring.)-/
instance mul : Mul (SkewMonoidAlgebra k G) :=
  ⟨fun f g => f.sum fun a₁ b₁ => g.sum fun a₂ b₂ => single (a₁ * a₂) (b₁ * (a₁ • b₂))⟩

theorem mul_def {f g : SkewMonoidAlgebra k G} :
    f * g = f.sum fun a₁ b₁ => g.sum fun a₂ b₂ => single (a₁ * a₂) (b₁ * (a₁ • b₂)) :=
  rfl

end SMul

section DistribSMul

variable [NonUnitalNonAssocSemiring k] [Mul G] [DistribSMul G k]

instance nonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring (SkewMonoidAlgebra k G) :=
  { Finsupp.addCommMonoid with
    left_distrib := fun f g h => by
      haveI := Classical.decEq G
      simp only [mul_def]
      refine Eq.trans (congr_arg (sum f) (funext₂ fun a₁ b₁ => sum_add_index ?_ ?_)) ?_ <;>
        simp only [smul_zero, smul_add, mul_add, mul_zero, single_zero, single_add,
          forall_true_iff, sum_add]
    right_distrib := fun f g h => by
      haveI := Classical.decEq G
      simp only [mul_def]
      refine Eq.trans (sum_add_index ?_ ?_) ?_ <;>
        simp only [add_mul, zero_mul, single_zero, single_add, forall_true_iff, sum_zero, sum_add]
    zero_mul := fun f => by
      simp only [mul_def]
      exact sum_zero_index
    mul_zero := fun f => by
      simp only [mul_def]
      exact Eq.trans (congr_arg (sum f) (funext₂ fun a₁ b₁ => sum_zero_index)) sum_zero }

end DistribSMul

section LiftNC

variable [Semiring R] [NonAssocSemiring k] [Mul G] [DistribSMul G k]

theorem liftNC_mul {g_hom : Type*} [FunLike g_hom G R] [MulHomClass g_hom G R] (f : k →+* R)
    (g : g_hom) (a b : SkewMonoidAlgebra k G)
    (h_comm : ∀ {x y}, y ∈ a.support → (f (y • b x)) * g y = (g y) * (f (b x))) :
    liftNC (f : k →+ R) g (a * b) = liftNC (f : k →+ R) g a * liftNC (f : k →+ R) g b := by
  conv_rhs => rw [← sum_single a, ← sum_single b]
  simp_rw [mul_def, map_finsupp_sum, liftNC_single, Finsupp.sum_mul, Finsupp.mul_sum]
  refine Finset.sum_congr rfl fun y hy => Finset.sum_congr rfl fun x _hx => ?_
  simp only [AddMonoidHom.coe_coe, map_mul]
  rw [mul_assoc, ← mul_assoc (f (y • b x)), h_comm hy]
  simp [mul_assoc]

end LiftNC

section MulSemiringAction

variable [Semiring k] [Monoid G] [MulSemiringAction G k]

instance nonUnitalSemiring : NonUnitalSemiring (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.nonUnitalNonAssocSemiring with
    mul_assoc := fun f g h => by
      simp only [mul_def]
      rw [sum_sum_index]; congr; ext a₁ b₁
      rw [sum_sum_index, sum_sum_index]; congr; ext a₂ b₂
      rw [sum_sum_index, sum_single_index]; congr; ext a₃ b₃
      rw [sum_single_index, mul_assoc, mul_assoc]
      all_goals simp only [smul_add, mul_smul, smul_mul', smul_zero, mul_zero, forall_const,
        single_zero, single_add, forall_true_iff, add_mul,
        mul_add, zero_mul, mul_zero, sum_zero, sum_add] }

end MulSemiringAction

section One

variable [NonAssocSemiring R] [NonAssocSemiring k] [One G]

/-- The unit of the multiplication is `single 1 1`, i.e. the function that is `1` at `1` and
  zero elsewhere. -/
instance one : One (SkewMonoidAlgebra k G) :=
  ⟨single 1 1⟩

theorem one_def : (1 : SkewMonoidAlgebra k G) = single 1 1 :=
  rfl

@[simp]
theorem liftNC_one {g_hom : Type*} [FunLike g_hom G R] [OneHomClass g_hom G R] (f : k →+* R)
    (g : g_hom) : liftNC (f : k →+ R) g 1 = 1 := by
  simp only [one_def, liftNC_single, AddMonoidHom.coe_coe, map_one, mul_one]

end One

section MulSemiringAction

variable [Semiring k] [Monoid G] [MulSemiringAction G k]

instance nonAssocSemiring : NonAssocSemiring (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.nonUnitalNonAssocSemiring with
    natCast := fun n => single 1 n
    natCast_zero := by simp only [Nat.cast_zero, single_zero]
    natCast_succ := fun _ => by simp only [Nat.cast_add, Nat.cast_one, single_add]; rfl
    one_mul := fun f => by
      simp only [one_def, mul_def, one_mul, one_smul, zero_mul, single_zero, sum_zero,
        sum_single_index]
      rw [sum_single]
    mul_one := fun f => by
      simp only [one_def, mul_def, mul_one, smul_zero, mul_zero, single_zero, sum_single_index,
        smul_one]
      rw [sum_single] }

theorem nat_cast_def (n : ℕ) : (n : SkewMonoidAlgebra k G) = single (1 : G) (n : k) :=
  rfl

end MulSemiringAction

/-! #### Semiring structure -/

section Semiring

variable [Semiring k] [Monoid G] [MulSemiringAction G k]

instance semiring : Semiring (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.nonUnitalSemiring,
    SkewMonoidAlgebra.nonAssocSemiring with }

variable [Semiring R]

/-- `liftNC` as a `RingHom`, for when `f x` and `g y` commute -/
def liftNCRingHom (f : k →+* R) (g : G →* R)
    (h_comm : ∀ {x y}, (f (y • x)) * g y = (g y) * (f x)) :
    SkewMonoidAlgebra k G →+* R :=
  { liftNC (f : k →+ R) g with
    map_one' := liftNC_one _ _
    map_mul' := fun _a _b => liftNC_mul _ _ _ _ fun {_ _} _ => h_comm }

end Semiring

instance nontrivial [Semiring k] [Nontrivial k] [Nonempty G] : Nontrivial (SkewMonoidAlgebra k G) :=
  Finsupp.nontrivial

/-! #### Derived instances -/

section DerivedInstances

instance unique [Semiring k] [Subsingleton k] : Unique (SkewMonoidAlgebra k G) :=
  Finsupp.uniqueOfRight

instance addCommGroup [Ring k] : AddCommGroup (SkewMonoidAlgebra k G) :=
  Finsupp.addCommGroup

instance nonUnitalNonAssocRing [Ring k] [Monoid G] [MulSemiringAction G k]:
    NonUnitalNonAssocRing (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.addCommGroup, SkewMonoidAlgebra.nonUnitalNonAssocSemiring with }

instance nonUnitalRing [Ring k] [Monoid G] [MulSemiringAction G k]:
    NonUnitalRing (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.addCommGroup, SkewMonoidAlgebra.nonUnitalSemiring with }

instance nonAssocRing [Ring k] [Monoid G] [MulSemiringAction G k]:
    NonAssocRing (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.addCommGroup,
    SkewMonoidAlgebra.nonAssocSemiring with
    intCast := fun z => single 1 (z : k)
    intCast_ofNat := fun n => by simp; rfl
    intCast_negSucc := fun n => by simp; rfl }

theorem int_cast_def [Ring k] [Monoid G] [MulSemiringAction G k] (z : ℤ) :
    (z : SkewMonoidAlgebra k G) = single (1 : G) (z : k) :=
  rfl

instance ring [Ring k] [Monoid G] [MulSemiringAction G k]: Ring (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.nonAssocRing, SkewMonoidAlgebra.semiring with }

variable {S : Type*}

instance smulZeroClass [Semiring k] [SMulZeroClass R k] : SMulZeroClass R (SkewMonoidAlgebra k G) :=
  Finsupp.smulZeroClass

instance distribSMul [Semiring k] [DistribSMul R k] : DistribSMul R (SkewMonoidAlgebra k G) :=
  Finsupp.distribSMul _ _

instance distribMulAction [Monoid R] [Semiring k] [DistribMulAction R k] :
    DistribMulAction R (SkewMonoidAlgebra k G) :=
  Finsupp.distribMulAction G k

instance module [Semiring R] [Semiring k] [Module R k] : Module R (SkewMonoidAlgebra k G) :=
  Finsupp.module G k

instance faithfulSMul [Monoid R] [Semiring k] [DistribMulAction R k] [FaithfulSMul R k]
    [Nonempty G] : FaithfulSMul R (SkewMonoidAlgebra k G) :=
  Finsupp.faithfulSMul

instance isScalarTower [Semiring k] [SMulZeroClass R k] [SMulZeroClass S k] [SMul R S]
    [IsScalarTower R S k] : IsScalarTower R S (SkewMonoidAlgebra k G) :=
  Finsupp.isScalarTower G k

instance smulCommClass [Monoid R] [Monoid S] [Semiring k] [DistribMulAction R k]
    [DistribMulAction S k] [SMulCommClass R S k] : SMulCommClass R S (SkewMonoidAlgebra k G) :=
  Finsupp.smulCommClass G k

instance isCentralScalar [Monoid R] [Semiring k] [DistribMulAction R k] [DistribMulAction Rᵐᵒᵖ k]
    [IsCentralScalar R k] : IsCentralScalar R (SkewMonoidAlgebra k G) :=
  Finsupp.isCentralScalar G k

/-- This is not an instance as it conflicts with `SkewMonoidAlgebra.distribMulAction`
  when `G = kˣ`. -/
def comapDistribMulActionSelf [Group G] [Semiring k] : DistribMulAction G (SkewMonoidAlgebra k G) :=
  Finsupp.comapDistribMulAction

end DerivedInstances

section MiscTheorems

variable [Semiring k]

theorem mul_apply [DecidableEq G] [Monoid G] [MulSemiringAction G k] (f g : SkewMonoidAlgebra k G)
    (x : G) : (f * g) x = f.sum fun a₁ b₁ => g.sum fun a₂ b₂ =>
    if a₁ * a₂ = x then b₁ * a₁ • b₂ else 0 := by
  rw [mul_def, Finsupp.sum_apply]; congr; ext
  rw [Finsupp.sum_apply]; congr; ext
  apply single_apply

theorem mul_apply_antidiagonal [Monoid G] (f g : SkewMonoidAlgebra k G) [MulSemiringAction G k]
    (x : G) (s : Finset (G × G)) (hs : ∀ {p : G × G}, p ∈ s ↔ p.1 * p.2 = x) :
    (f * g) x = ∑ p in s, f p.1 * p.1 • g p.2 := by
  classical
    let F : G × G → k := fun p => if p.1 * p.2 = x then f p.1 * p.1 • g p.2 else 0
    calc
      (f * g) x = ∑ a₁ in f.support, ∑ a₂ in g.support, F (a₁, a₂) := mul_apply f g x
      _ = ∑ p in f.support ×ˢ g.support, F p := Finset.sum_product.symm
      _ = ∑ p in (f.support ×ˢ g.support).filter fun p : G × G =>
          p.1 * p.2 = x, f p.1 * p.1 • g p.2 := (Finset.sum_filter _ _).symm
      _ = ∑ p in s.filter fun p : G × G => p.1 ∈ f.support ∧ p.2 ∈ g.support, f p.1 * p.1 • g p.2 :=
        (sum_congr
          (by
            ext
            simp only [mem_filter, mem_product, hs, and_comm])
          fun _ _ => rfl)
      _ = ∑ p in s, f p.1 * p.1 • g p.2 :=
        sum_subset (filter_subset _ _) fun p hps hp => by
          simp only [mem_filter, mem_support_iff, not_and, Classical.not_not] at hp ⊢
          by_cases h1 : f p.1 = 0
          · rw [h1, zero_mul]
          · rw [hp hps h1, smul_zero, mul_zero]

@[simp]
theorem single_mul_single [Monoid G] [MulSemiringAction G k] {a₁ a₂ : G} {b₁ b₂ : k} :
    (single a₁ b₁) * (single a₂ b₂) = single (a₁ * a₂) (b₁ * a₁ • b₂) :=
  (sum_single_index (by simp only [zero_mul, single_zero, sum_zero])).trans
    (sum_single_index (by simp only [smul_zero, mul_zero, single_zero]))

section

open Finsupp

/-- Like `Finsupp.mapDomain_zero`, but for the `1` we define in this file -/
theorem mapDomain_one {α : Type*} {β : Type*} {α₂ : Type*} [Semiring β] [Monoid α] [Monoid α₂]
    {F : Type*} [FunLike F α α₂] [MonoidHomClass F α α₂] (f : F) :
    (mapDomain f (1 : SkewMonoidAlgebra β α) : SkewMonoidAlgebra β α₂) =
      (1 : SkewMonoidAlgebra β α₂) := by
  simp_rw [one_def, mapDomain_single, map_one]

/- Like `Finsupp.mapDomain_add`, but for the skewed convolutive multiplication we define in this
  file. This theorem holds assuming that `(hf : ∀ (a : α) (x : β), a • x = (f a) • x)`. -/
theorem mapDomain_mul {α : Type*} {β : Type*} {α₂ : Type*} [Semiring β] [Monoid α]
    [MulSemiringAction α β] [Monoid α₂] [MulSemiringAction α₂ β]
    {F : Type*} [FunLike F α α₂] [MulHomClass F α α₂] {f : F} (x y : SkewMonoidAlgebra β α)
    (hf : ∀ (a : α) (x : β), a • x = (f a) • x) :
    mapDomain f (x * y) = mapDomain f x * mapDomain f y := by
  simp only [mul_def]
  rw [mapDomain_sum]
  have : (sum x fun a b => sum y fun a₂ b₂ =>
      Finsupp.mapDomain (↑f) (single (a * a₂) (b *a • b₂))) =
      sum (Finsupp.mapDomain (↑f) x) fun a₁ b₁ =>
        sum (Finsupp.mapDomain (↑f) y) fun a₂ b₂ => single (a₁ * a₂) (b₁ * a₁ • b₂) := by
    simp_rw [mapDomain_single, map_mul]
    rw [Finsupp.sum_mapDomain_index]
    · congr
      ext a b c
      rw [Finsupp.sum_mapDomain_index]
      · congr
        ext a₂ b₂ a₃
        rw [hf]
      · simp [mul_add]
      · intros a₂ b₁ b₂
        simp only [smul_add, mul_add, single]
        rw [Finsupp.single_add]
    · simp only [zero_mul, Finsupp.single_zero, sum_zero, forall_const]
    · simp only [add_mul, Finsupp.single_add, sum_add, forall_const]
  convert this
  rw [mapDomain_sum]

variable (k G)

/-- The embedding of a monoid into its skew monoid algebra. -/
@[simps]
def of [Monoid G] [MulSemiringAction G k]: G →* SkewMonoidAlgebra k G where
  toFun a := single a 1
  map_one' := rfl
  map_mul' a b := by simp only [single_mul_single, smul_one, mul_one]

end

theorem smul_of [Monoid G] [MulSemiringAction G k] (g : G) (r : k) : r • of k G g = single g r := by
  rw [of_apply, smul_single', mul_one]

theorem of_injective [Monoid G] [MulSemiringAction G k] [Nontrivial k] :
    Function.Injective (of k G) := fun a b h => by
  simpa using (single_eq_single_iff _ _ _ _).mp h

theorem mul_single_apply_aux [Monoid G] [MulSemiringAction G k] (f : SkewMonoidAlgebra k G) {r : k}
    {x y z : G} (H : ∀ a, a * x = z ↔ a = y) : (f * single x r) z = f y * y • r := by
  classical exact
      have A :
        ∀ a₁ b₁,
          ((single x r).sum fun a₂ b₂ => ite (a₁ * a₂ = z) (b₁ * a₁ • b₂) 0) =
            ite (a₁ * x = z) (b₁ * a₁ • r) 0 :=
        fun a₁ b₁ => sum_single_index <| by simp
      calc
        (HMul.hMul (β := SkewMonoidAlgebra k G) f (single x r)) z =
            sum f fun a b => if a = y then b * y • r else 0 := by simp only [mul_apply, A, H]; simp
              only [Finsupp.sum_ite_eq', mem_support_iff, ne_eq, ite_not]
        _ = if y ∈ f.support then f y * y • r else 0 := (f.support.sum_ite_eq' _ _)
        _ = f y * y • r := by split_ifs with h <;> simp at h <;> simp [h]

theorem mul_single_one_apply [Monoid G] (f : SkewMonoidAlgebra k G) [MulSemiringAction G k] (r : k)
    (x : G) : (HMul.hMul (β := SkewMonoidAlgebra k G) f (single 1 r)) x = f x * x • r :=
  f.mul_single_apply_aux fun a => by rw [mul_one]

theorem mul_single_apply_of_not_exists_mul [Monoid G] [MulSemiringAction G k] (r : k) {g g' : G}
    (x : SkewMonoidAlgebra k G) (h : ¬∃ d, g' = d * g) : (x * single g r) g' = 0 := by
  classical
    rw [mul_apply, Finsupp.sum_comm, Finsupp.sum_single_index]
    swap
    · simp_rw [Finsupp.sum, smul_zero, mul_zero, ite_self, Finset.sum_const_zero]
    · apply Finset.sum_eq_zero
      simp_rw [ite_eq_right_iff]
      rintro g'' _hg'' rfl
      exfalso
      exact h ⟨_, rfl⟩

theorem single_mul_apply_aux [Monoid G] (f : SkewMonoidAlgebra k G) [MulSemiringAction G k] {r : k}
    {x y z : G} (H : ∀ a, x * a = y ↔ a = z) : (single x r * f) y = r * x • f z := by
  classical exact
      have : (f.sum fun a b => ite (x * a = y) (0 * x • b) 0) = 0 := by simp
      calc
        (HMul.hMul (α := SkewMonoidAlgebra k G) (single x r) f) y =
            sum f fun a b => ite (x * a = y) (r * x • b) 0 :=
          (mul_apply _ _ _).trans <| sum_single_index this
        _ = f.sum fun a b => ite (a = z) (r * x • b) 0 := by simp only [H]
        _ = if z ∈ f.support then r * x • f z else 0 := (f.support.sum_ite_eq' _ _)
        _ = _ := by split_ifs with h <;> simp at h <;> simp [h]

theorem single_one_mul_apply [Monoid G] (f : SkewMonoidAlgebra k G) [MulSemiringAction G k] (r : k)
    (x : G) : (single (1 : G) r * f) x = r * f x := by
  rw [single_mul_apply_aux, one_smul]
  simp only [one_mul, forall_const]

theorem single_mul_apply_of_not_exists_mul [Monoid G] [MulSemiringAction G k] (r : k) {g g' : G}
    (x : SkewMonoidAlgebra k G) (h : ¬∃ d, g' = g * d) : (single g r * x) g' = 0 := by
  classical
    rw [mul_apply, Finsupp.sum_single_index]
    swap
    · simp_rw [Finsupp.sum, zero_mul, ite_self, Finset.sum_const_zero]
    · apply Finset.sum_eq_zero
      simp_rw [ite_eq_right_iff]
      rintro g'' _hg'' rfl
      exfalso
      exact h ⟨_, rfl⟩

theorem liftNC_smul [MulOneClass G] {R : Type*} [Semiring R] (f : k →+* R) (g : G →* R) (c : k)
    (φ : SkewMonoidAlgebra k G) :
    liftNC (f : k →+ R) g (c • φ) = f c * liftNC (f : k →+ R) g φ := by
  suffices :
    (liftNC (↑f) g).comp (smulAddHom k (SkewMonoidAlgebra k G) c) =
      (AddMonoidHom.mulLeft (f c)).comp (liftNC (↑f) g)
  exact DFunLike.congr_fun this φ
  refine addHom_ext' fun a => AddMonoidHom.ext fun b => ?_
  unfold SkewMonoidAlgebra
  simp only [AddMonoidHom.coe_comp, Function.comp_apply, singleAddHom_apply, smulAddHom_apply,
    smul_single, smul_eq_mul, AddMonoidHom.coe_mulLeft]
  erw [liftNC_single, liftNC_single]
  rw [AddMonoidHom.coe_coe, map_mul, mul_assoc]

end MiscTheorems

/-! #### Non-unital, non-associative algebra structure -/
section NonUnitalNonAssocAlgebra

variable (k) [Semiring k] [DistribSMul R k] [Monoid G] [MulSemiringAction G k]

instance isScalarTower_self [IsScalarTower R k k] :
    IsScalarTower R (SkewMonoidAlgebra k G) (SkewMonoidAlgebra k G) :=
  ⟨fun t a b => by
    refine Finsupp.ext fun m => ?_
    classical
      simp only [smul_eq_mul, mul_apply]
      rw [coe_smul]
      refine Eq.trans (sum_smul_index' (g := a) (b := t) ?_) ?_ <;>
        simp only [mul_apply, Finsupp.smul_sum, smul_ite, smul_mul_assoc,
          zero_mul, ite_self, imp_true_iff, sum_zero, Pi.smul_apply, smul_zero]⟩

variable {A : Type u₃} [NonUnitalNonAssocSemiring A]

/-- A non_unital `k`-algebra homomorphism from `SkewMonoidAlgebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem nonUnitalAlgHom_ext [DistribMulAction k A] {φ₁ φ₂ : SkewMonoidAlgebra k G →ₙₐ[k] A}
    (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=
  NonUnitalAlgHom.to_distribMulActionHom_injective <|
    Finsupp.distribMulActionHom_ext' fun a => DistribMulActionHom.ext_ring (h a)

/-- See note [partially-applied ext lemmas]. -/
@[ext high]
theorem nonUnitalAlgHom_ext' [DistribMulAction k A] {φ₁ φ₂ : SkewMonoidAlgebra k G →ₙₐ[k] A}
    (h : φ₁.toMulHom.comp (of k G).toMulHom = φ₂.toMulHom.comp (of k G).toMulHom) : φ₁ = φ₂ :=
  nonUnitalAlgHom_ext k <| DFunLike.congr_fun h

end NonUnitalNonAssocAlgebra

/-! #### Algebra structure -/

section Algebra

/-- `Finsupp.single 1` as a `RingHom` -/
def singleOneRingHom [Semiring k] [Monoid G] [MulSemiringAction G k] :
    k →+* SkewMonoidAlgebra k G :=
  { Finsupp.singleAddHom 1 with
    map_one' := rfl
    map_mul' := fun x y => by
      simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe, singleAddHom_apply,
        single_mul_single, mul_one]
      simp only [one_smul] }

/-- If f : G → H is a multiplicative homomorphism between two monoids and
  `∀ (a : G) (x : k), a • x = (f a) • x`, then `Finsupp.mapDomain f` is a ring homomorphism
  between their skew monoid algebras. -/
def mapDomainRingHom (k : Type*) {H F : Type*} [Semiring k] [Monoid G] [Monoid H] [FunLike F G H]
    [MonoidHomClass F G H] [MulSemiringAction G k] [MulSemiringAction H k] {f : F}
    (hf : ∀ (a : G) (x : k), a • x = (f a) • x) :
    SkewMonoidAlgebra k G →+* SkewMonoidAlgebra k H :=
  { (Finsupp.mapDomain.addMonoidHom f : SkewMonoidAlgebra k G →+ SkewMonoidAlgebra k H) with
    map_one' := mapDomain_one f
    map_mul' := fun x y => mapDomain_mul x y hf }

/-- If two ring homomorphisms from `SkewMonoidAlgebra k G` are equal on all `single a 1`
and `single 1 b`, then they are equal. -/
theorem ringHom_ext {R} [Semiring k] [Monoid G] [Semiring R] [MulSemiringAction G k]
    {f g : SkewMonoidAlgebra k G →+* R}
    (h₁ : ∀ b, f (single 1 b) = g (single 1 b)) (h_of : ∀ a, f (single a 1) = g (single a 1)) :
    f = g :=
  have {a : G} {b₁ b₂ : k} : (single 1 b₁) * (single a b₂) = single a (b₁ * b₂) := by
    simp only [single_mul_single, one_mul, one_smul]
  RingHom.coe_addMonoidHom_injective <|
    addHom_ext fun a b => by
      rw [← single,  ← mul_one b, ← this]
      erw [AddMonoidHom.coe_coe f, AddMonoidHom.coe_coe g]; rw [f.map_mul, g.map_mul, h₁, h_of]

/-- If two ring homomorphisms from `SkewMonoidAlgebra k G` are equal on all `single a 1`
and `single 1 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext high]
theorem ringHom_ext' {R} [Semiring k] [Monoid G] [Semiring R] [MulSemiringAction G k]
    {f g : SkewMonoidAlgebra k G →+* R} (h₁ : f.comp singleOneRingHom = g.comp singleOneRingHom)
    (h_of : (f : SkewMonoidAlgebra k G →* R).comp (of k G) =
      (g : SkewMonoidAlgebra k G →* R).comp (of k G)) : f = g :=
  ringHom_ext (RingHom.congr_fun h₁) (DFunLike.congr_fun h_of)

/-- The class `SmulTrivAction` of actions of `G` on `A` that are trivial on the embedding of `k`
  into `A` given by the `Algebra` structure.-/
class SmulTrivAction (G k A : Type*) [CommSemiring k] [Semiring A] [Monoid G] [SMul G A]
    [Algebra k A] : Prop where
  smul_triv : ∀ (g : G) (r : k), g • (algebraMap k A r) = algebraMap k A r


/-- The instance `Algebra k (SkewMonoidAlgebra A G)` whenever we have `Algebra k A`.
  In particular this provides the instance `Algebra k (SkewMonoidAlgebra k G)`.
  This requires `SmulTrivAction G k A`. -/
instance algebra {A : Type*} [CommSemiring k] [Semiring A] [Monoid G] [MulSemiringAction G A]
    [Algebra k A] [SmulTrivAction G k A] :
    Algebra k (SkewMonoidAlgebra A G) :=
  { singleOneRingHom.comp (algebraMap k A) with
    smul_def' := fun r a => by
      refine Finsupp.ext fun _ => ?_
      rw [Finsupp.coe_smul]
      simp only [Pi.smul_apply, Algebra.smul_def, RingHom.toMonoidHom_eq_coe, RingHom.coe_mk,
        MonoidHom.coe_coe, RingHom.coe_comp, Function.comp_apply, singleOneRingHom, singleAddHom]
      simp only [ZeroHom.toFun_eq_coe, ZeroHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk,
        single_one_mul_apply]
    commutes' := fun r f => by
      refine Finsupp.ext fun g => ?_
      simp [singleOneRingHom, singleAddHom]
      rw [single_one_mul_apply, mul_single_one_apply, Algebra.commutes, SmulTrivAction.smul_triv] }

@[simp]
theorem coe_algebraMap {A : Type*} [CommSemiring k] [Semiring A] [Algebra k A] [Monoid G]
    [MulSemiringAction G A] [SmulTrivAction G k A] :
    ⇑(@algebraMap k (SkewMonoidAlgebra A G) _ _ _) = single 1 ∘ algebraMap k A :=
  rfl

theorem single_eq_algebraMap_mul_of [CommSemiring k] [Monoid G] (a : G) (b : k)
    [MulSemiringAction G k] [SmulTrivAction G k k] :
    single a b = (@algebraMap k (SkewMonoidAlgebra k G) _ _ _) b * of k G a := by simp

theorem single_algebraMap_eq_algebraMap_mul_of {A : Type*} [CommSemiring k] [Semiring A]
    [Algebra k A] [Monoid G] (a : G) (b : k) [MulSemiringAction G A] [SmulTrivAction G k A] :
    single a (algebraMap k A b) = (algebraMap k (SkewMonoidAlgebra A G)) b * of A G a := by
      simp only [coe_algebraMap, Function.comp_apply, of_apply, single_mul_single, one_mul,
        smul_one, mul_one]

end Algebra

section lift

variable [CommSemiring k] [Monoid G] [Monoid H] [MulSemiringAction G k] [MulSemiringAction H k]

variable {A : Type u₃} [Semiring A] [Algebra k A] {B : Type*} [Semiring B] [Algebra k B]
variable [MulSemiringAction G A]

/-- `liftNCRingHom` as an `AlgHom`, for when `f` is an `AlgHom` and
  `∀ {x y}, (f (y • x)) * g y = (g y) * (f x)`.-/
def liftNCAlgHom (f : A →ₐ[k] B) (g : G →* B) (h_comm : ∀ {x y}, (f (y • x)) * g y = (g y) * (f x))
    [SmulTrivAction G k A] :
    AlgHom k (SkewMonoidAlgebra A G) B := by
  use liftNCRingHom (f : A →+* B) g h_comm
  simp [liftNCRingHom]

/- Hypothesis needed for `k`-algebra homomorphism from `SkewMonoidAlgebra k G`-/
variable [SmulTrivAction G k k]

lemma SmulTrivAction.smul_triv' (g : G) (r : k) : g • r = r := by
  have : algebraMap k k r = r := rfl
  rw [← this, SmulTrivAction.smul_triv]

/-- A `k`-algebra homomorphism from `SkewMonoidAlgebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem algHom_ext ⦃φ₁ φ₂ : AlgHom k (SkewMonoidAlgebra k G) A ⦄
    (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=
    AlgHom.toLinearMap_injective (Finsupp.lhom_ext' fun a => (LinearMap.ext_ring (h a)))

@[ext high]
theorem algHom_ext' ⦃φ₁ φ₂ : AlgHom k (SkewMonoidAlgebra k G) A⦄
    (h : (φ₁ : SkewMonoidAlgebra k G →* A).comp (of k G) =
      (φ₂ : SkewMonoidAlgebra k G →* A).comp (of k G)) :
    φ₁ = φ₂ :=  algHom_ext <| DFunLike.congr_fun h

variable (k G A)

/-- Any monoid homomorphism `G →* A` can be lifted to an algebra homomorphism
  `SkewMonoidAlgebra k G →ₐ[k] A`. -/
def lift : (G →* A) ≃ (AlgHom k (SkewMonoidAlgebra k G) A) where
  invFun f := (f : SkewMonoidAlgebra k G →* A).comp  (of k G)
  toFun F := by
    apply liftNCAlgHom (Algebra.ofId k A) F
    simp_rw [SmulTrivAction.smul_triv']
    exact Algebra.commutes _ _
  left_inv f := by
    ext
    simp [liftNCAlgHom, liftNCRingHom]
  right_inv F := by
    ext
    simp [liftNCAlgHom, liftNCRingHom]

variable {k G H A}

theorem lift_apply' (F : G →* A) (f : SkewMonoidAlgebra k G) :
    lift k G A F f = f.sum fun a b => algebraMap k A b * F a := rfl

theorem lift_apply (F : G →* A) (f : SkewMonoidAlgebra k G) :
    lift k G A F f = f.sum fun a b => b • F a := by simp only [lift_apply', Algebra.smul_def]


theorem lift_def (F : G →* A) : ⇑(lift k G A F) =
    liftNC ((algebraMap k A : k →+* A) : k →+ A) F := rfl

@[simp]
theorem lift_symm_apply (F : AlgHom k (SkewMonoidAlgebra k G) A) (x : G) :
    (lift k G A).symm F x = F (single x 1) := rfl

theorem lift_of (F : G →* A) (x) : lift k G A F (of k G x) = F x := by
  rw [of_apply, ← lift_symm_apply, Equiv.symm_apply_apply]

@[simp]
theorem lift_single (F : G →* A) (a b) : lift k G A F (single a b) = b • F a := by
  rw [lift_def, liftNC_single, Algebra.smul_def, AddMonoidHom.coe_coe]


theorem lift_unique' (F : AlgHom k (SkewMonoidAlgebra k G) A) :
    F = lift k G A ((F : SkewMonoidAlgebra k G →* A).comp (of k G)) :=
  ((lift k G A).apply_symm_apply F).symm

/-- Decomposition of a `k`-algebra homomorphism from `SkewMonoidAlgebra k G` by
  its values on `F (single a 1)`. -/
theorem lift_unique (F : AlgHom k (SkewMonoidAlgebra k G) A)
    (f : SkewMonoidAlgebra k G) : F f  = f.sum fun a b => b • F (single a 1) := by
  conv_lhs =>
    rw [lift_unique' F]
    simp [lift_apply]

variable (A) in
theorem mapDomain_algebraMap
    {F : Type*} [FunLike F G H] [MonoidHomClass F G H] [MulSemiringAction G A]
    [MulSemiringAction H A] [SmulTrivAction G k A] [SmulTrivAction H k A] (f : F) (r : k) :
    mapDomain f (algebraMap k (SkewMonoidAlgebra A G) r) =
      algebraMap k (SkewMonoidAlgebra A H) r := by
  simp only [coe_algebraMap, mapDomain_single, map_one, (· ∘ ·)]

/-- If `f : G → H` is a multiplicative homomorphism between two monoids, then
`Finsupp.mapDomain f` is an algebra homomorphism between their monoid algebras. -/
@[simps!]
def mapDomainAlgHom (k A : Type*) [CommSemiring k] [Semiring A] [Algebra k A] {H F : Type*}
    [Monoid H] [FunLike F G H] [MonoidHomClass F G H] [MulSemiringAction G A]
    [MulSemiringAction H A] [SmulTrivAction G k A] [SmulTrivAction H k A] {f : F}
    (hf : ∀ (a : G) (x : A), a • x = (f a) • x) :
    SkewMonoidAlgebra A G →ₐ[k] SkewMonoidAlgebra A H :=
  { mapDomainRingHom A hf with
    commutes' := mapDomain_algebraMap A f }

variable (k A)

/-- If `e : G ≃* H` is a multiplicative equivalence between two monoids and
 ` ∀ (a : G) (x : A), a • x = (e a) • x`, then `SkewMonoidAlgebra.domCongr e` is an
  algebra equivalence between their skew monoid algebras. -/
def domCongr [MulSemiringAction G A] [MulSemiringAction H A] [SmulTrivAction G k A]
    [SmulTrivAction H k A] {e : G ≃* H} (he : ∀ (a : G) (x : A), a • x = (e a) • x) :
    SkewMonoidAlgebra A G ≃ₐ[k] SkewMonoidAlgebra A H :=
  AlgEquiv.ofLinearEquiv
    (Finsupp.domLCongr e : (G →₀ A) ≃ₗ[k] (H →₀ A))
    ((equivMapDomain_eq_mapDomain _ _).trans <| mapDomain_one e)
    (fun f g => (equivMapDomain_eq_mapDomain _ _).trans <| (mapDomain_mul f g he).trans <|
        congr_arg₂ _ (equivMapDomain_eq_mapDomain _ _).symm (equivMapDomain_eq_mapDomain _ _).symm)

theorem domCongr_toAlgHom [MulSemiringAction G A] [MulSemiringAction H A] [SmulTrivAction G k A]
    [SmulTrivAction H k A] {e : G ≃* H} (he : ∀ (a : G) (x : A), a • x = (e a) • x) :
    (domCongr k A he).toAlgHom = mapDomainAlgHom k A he :=
  AlgHom.ext <| fun _ => equivMapDomain_eq_mapDomain _ _

@[simp] theorem domCongr_apply [MulSemiringAction G A] [MulSemiringAction H A]
    [SmulTrivAction G k A] [SmulTrivAction H k A] {e : G ≃* H}
    (he : ∀ (a : G) (x : A), a • x = (e a) • x) (f : SkewMonoidAlgebra A G) (h : H) :
    domCongr k A he f h = f (e.symm h) :=
  rfl

@[simp] theorem domCongr_support [MulSemiringAction G A] [MulSemiringAction H A]
    [SmulTrivAction G k A] [SmulTrivAction H k A] {e : G ≃* H}
    (he : ∀ (a : G) (x : A), a • x = (e a) • x) (f : SkewMonoidAlgebra A G) :
    (domCongr k A he f).support = f.support.map e :=
  rfl

@[simp] theorem domCongr_single [MulSemiringAction G A] [MulSemiringAction H A]
    [SmulTrivAction G k A] [SmulTrivAction H k A] {e : G ≃* H}
    (he : ∀ (a : G) (x : A), a • x = (e a) • x) (g : G) (a : A) :
    domCongr k A he (single g a) = single (e g) a :=
  Finsupp.equivMapDomain_single _ _ _

theorem domCongr_refl [MulSemiringAction G A] [SmulTrivAction G k A] :
    @domCongr k _ _ _ _ _ A _ _ _ _ _ _ (MulEquiv.refl G) (fun _ _ => rfl) = AlgEquiv.refl :=
  AlgEquiv.ext fun _ => Finsupp.ext fun _ => rfl

@[simp] theorem domCongr_symm [MulSemiringAction G A] [MulSemiringAction H A]
    [SmulTrivAction G k A] [SmulTrivAction H k A] {e : G ≃* H}
    (he : ∀ (a : G) (x : A), a • x = (e a) • x) :
    (domCongr k A he).symm = @domCongr k _ _ _ _ _ A _ _ _ _ _ _ e.symm
      (fun a x => by rw [he, MulEquiv.apply_symm_apply]) := rfl

end lift

section

variable [Monoid G] [CommSemiring k] {V : Type u₃} {W : Type u₄} [AddCommMonoid V] [Module k V]
  [MulSemiringAction G k] [Module (SkewMonoidAlgebra k G) V]
  [IsScalarTower k (SkewMonoidAlgebra k G) V] [AddCommMonoid W] [Module k W]
  [Module (SkewMonoidAlgebra k G) W] [IsScalarTower k (SkewMonoidAlgebra k G) W] (f : V →ₗ[k] W)
  (h : ∀ (g : G) (v : V), f (single g (1 : k) • v) = single g (1 : k) • f v)

/-- Build a `k[G]`-linear map from a `k`-linear map and evidence that it is `G`-equivariant. -/
def equivariantOfLinearOfComm [SmulTrivAction G k k] : V →ₗ[SkewMonoidAlgebra k G] W where
  toFun := f
  map_add' v v' := by simp
  map_smul' c v := by
    dsimp only []
    refine Finsupp.induction c ?_ ?_
    · simp
    · intro g r c' _nm _nz w
      dsimp at *
      simp only [add_smul, f.map_add, w, add_left_inj, single_eq_algebraMap_mul_of, ← smul_smul]
      erw [algebraMap_smul (SkewMonoidAlgebra k G) r, algebraMap_smul (SkewMonoidAlgebra k G) r,
        f.map_smul, h g v, of_apply]

@[simp]
theorem equivariantOfLinearOfComm_apply [SmulTrivAction G k k] (v : V) :
    (equivariantOfLinearOfComm f h) v = f v := rfl

end

section

-- We now prove some additional statements that hold for group algebras.
variable [Semiring k] [Group G] [MulSemiringAction G k]

@[simp]
theorem mul_single_apply (f : SkewMonoidAlgebra k G) (r : k) (x y : G) :
    (f * single x r) y = f (y * x⁻¹) * (y * x⁻¹) • r :=
  f.mul_single_apply_aux fun _a => eq_mul_inv_iff_mul_eq.symm

@[simp]
theorem single_mul_apply (r : k) (x : G) (f : SkewMonoidAlgebra k G) (y : G) :
    (single x r * f) y = r * x • f (x⁻¹ * y) :=
  f.single_mul_apply_aux fun _z => eq_inv_mul_iff_mul_eq.symm

theorem mul_apply_left (f g : SkewMonoidAlgebra k G) (x : G) :
    (f * g) x = f.sum fun a b => b * a • g (a⁻¹ * x) :=
  calc
    (f * g) x = sum f fun a b => (single a b * g) x := by
      rw [← Finsupp.sum_apply, ← Finsupp.sum_mul g f, f.sum_single]
    _ = _ := by simp only [single_mul_apply, Finsupp.sum]

theorem mul_apply_right (f g : SkewMonoidAlgebra k G) (x : G) :
    (f * g) x = g.sum fun a b => f (x * a⁻¹) * (x * a⁻¹) • b :=
  calc
    (f * g) x = sum g fun a b => (f * single a b) x := by
      rw [← Finsupp.sum_apply, ← Finsupp.mul_sum f g, g.sum_single]
    _ = _ := by simp only [mul_single_apply, Finsupp.sum]

end

section Submodule

variable [CommSemiring k] [Monoid G] [MulSemiringAction G k]

variable {V : Type*} [AddCommMonoid V]

variable [Module k V] [Module (SkewMonoidAlgebra k G) V] [IsScalarTower k (SkewMonoidAlgebra k G) V]

/-- A submodule over `k` which is stable under scalar multiplication by elements of `G` is a
submodule over `SkewMonoidAlgebra k G`  -/
def submoduleOfSmulMem (W : Submodule k V) (h : ∀ (g : G) (v : V), v ∈ W → of k G g • v ∈ W) :
    Submodule (SkewMonoidAlgebra k G) V where
  carrier := W
  zero_mem' := W.zero_mem'
  add_mem' := W.add_mem'
  smul_mem' := by
    intro f v hv
    rw [← Finsupp.sum_single f, Finsupp.sum, Finset.sum_smul]
    simp_rw [← smul_of, smul_assoc]
    exact Submodule.sum_smul_mem W _ fun g _ => h g v hv

end Submodule

end SkewMonoidAlgebra
