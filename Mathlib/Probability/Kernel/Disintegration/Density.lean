/-
Copyright (c) 2024 Rémy Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Rémy Degenne
-/
import Mathlib.Probability.Kernel.Composition
import Mathlib.Probability.Martingale.Convergence
import Mathlib.Analysis.SpecialFunctions.Log.Base
import Mathlib.Probability.Kernel.Disintegration.AuxLemmas

/-!
# Kernel density

Let `κ : kernel α (ℝ × β)` and `ν : kernel α ℝ` be two finite kernels with `kernel.fst κ ≤ ν`.
We build a function `f : α → ℝ → Set β → ℝ` jointly measurable in the first two arguments such that
for all `a : α` and all measurable sets `s : Set β` and `A : Set ℝ`,
`∫ t in A, f a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal`.

If we were interested only in a fixed `a : α`, then we could use the Radon-Nikodym derivative to
build the function `f`, as follows
```
def f_a (κ : kernel α (ℝ × β)) (ν : kernel a ℝ) (a : α) (t : ℝ) (s : Set β) : ℝ :=
  (((κ a).restrict (univ ×ˢ s)).fst.rnDeriv (ν a) t).toReal
```
However, we can't turn those functions for each `a` into a measurable function of the pair `(a, t)`.

In order to obtain measurability through countability, we discretize the real line.
For each `n : ℕ`, we define the intervals `I n k = [k * 2^-n, (k + 1) * 2^-n)` for `k : ℤ`.
For `t : ℝ`, let `indexI n t = ⌊t * 2^n⌋` be the integer such that `t ∈ I n (indexI n t)`.

For a given `n`, the function `densityProcess κ ν n : α → ℝ → Set β → ℝ` defined by
`fun a t s ↦ (κ a (I n (indexI n t) ×ˢ s) / ν a (I n (indexI n t))).toReal` has the desired
property that `∫ t in A, densityProcess κ ν n a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal` for all `A`
in the σ-algebra generated by the intervals `I n k` for `k : ℤ` and is measurable in `(a, t)`.

Let `ℱ` be the filtration of those σ-algebras for all `n : ℕ`. The functions `densityProcess κ ν n`
described here are a bounded `ν`-martingale for the filtration `ℱ`. By Doob's L1 martingale
convergence theorem, that martingale converges to a limit, which has a product-measurable version
and satisfies the integral equality for all `A` in `⨆ n, ℱ n = borel ℝ`. We have obtained the
desired density function.

## Main definitions

* `FooBar`

## Main statements

* `fooBar_unique`

## Implementation details


## References

The construction of the density process in this file follows the proof of Theorem 9.27 in
[O. Kallenberg, Foundations of modern probability][kallenberg2021].
-/


open MeasureTheory Set Filter

open scoped NNReal ENNReal MeasureTheory Topology ProbabilityTheory

namespace ProbabilityTheory

variable {α β : Type*} {mα : MeasurableSpace α}

section dissection_system

def IcoPowTwo (n : ℕ) (k : ℤ) : Set ℝ := Set.Ico (k * (2⁻¹ : ℝ) ^ n) ((k + 1) * ((2 : ℝ) ^ n)⁻¹)

lemma mem_IcoPowTwo_iff_mul {n : ℕ} {k : ℤ} (x : ℝ) :
    x ∈ IcoPowTwo n k ↔ k ≤ x * 2 ^ n ∧ x * 2 ^ n < k + 1 := by
  simp only [IcoPowTwo, inv_pow, mem_Ico]
  rw [← div_eq_mul_inv, div_le_iff, ← div_eq_mul_inv, lt_div_iff]
  · positivity
  · positivity

lemma mem_IcoPowTwo_iff_floor {n : ℕ} {k : ℤ} (x : ℝ) : x ∈ IcoPowTwo n k ↔ ⌊x * 2 ^ n⌋ = k := by
  simp [mem_IcoPowTwo_iff_mul, Int.floor_eq_iff]

lemma measurableSet_IcoPowTwo (n : ℕ) (k : ℤ) : MeasurableSet (IcoPowTwo n k) := measurableSet_Ico

lemma Measure.iInf_Iic_gt_prod {ρ : Measure (α × ℝ)} [IsFiniteMeasure ρ]
    {s : Set α} (hs : MeasurableSet s) (t : ℚ) :
    ⨅ r : { r' : ℚ // t < r' }, ρ (s ×ˢ Iic (r : ℝ)) = ρ (s ×ˢ Iic (t : ℝ)) := by
  rw [← measure_iInter_eq_iInf]
  · rw [← prod_iInter]
    congr with x : 1
    simp only [mem_iInter, mem_Iic, Subtype.forall, Subtype.coe_mk]
    refine' ⟨fun h => _, fun h a hta => h.trans _⟩
    · refine' le_of_forall_lt_rat_imp_le fun q htq => h q _
      exact mod_cast htq
    · exact mod_cast hta.le
  · exact fun _ => hs.prod measurableSet_Iic
  · refine' Monotone.directed_ge fun r r' hrr' => prod_subset_prod_iff.mpr (Or.inl ⟨subset_rfl, _⟩)
    refine' Iic_subset_Iic.mpr _
    exact mod_cast hrr'
  · exact ⟨⟨t + 1, lt_add_one _⟩, measure_ne_top ρ _⟩

lemma pairwise_disjoint_IcoPowTwo (n : ℕ) : Pairwise (Disjoint on fun k ↦ IcoPowTwo n k) := by
  intro i j hij
  rw [Function.onFun, Set.disjoint_iff]
  intro x
  simp only [mem_inter_iff, mem_IcoPowTwo_iff_floor, mem_empty_iff_false, and_imp, imp_false]
  intro hi hj
  rw [hi] at hj
  exact hij hj

lemma IcoPowTwo_succ_union (n : ℕ) (k : ℤ) :
    IcoPowTwo (n+1) (2 * k) ∪ IcoPowTwo (n+1) (2 * k + 1) = IcoPowTwo n k := by
  ext x
  cases lt_or_le x ((2 * k + 1) * ((2 : ℝ) ^ (n+1))⁻¹) with
  | inl h =>
    simp only [IcoPowTwo, inv_pow, mem_Ico, Int.cast_mul, Int.int_cast_ofNat, Int.cast_add,
      Int.cast_one, mem_union, h, and_true, not_le.mpr h, false_and, or_false]
    have : x < (k + 1) * (2 ^ n)⁻¹ := by
      refine h.trans_le ?_
      rw [pow_add, pow_one, mul_inv, mul_comm _ 2⁻¹, ← mul_assoc]
      gcongr
      rw [add_mul, one_mul, mul_comm, ← mul_assoc, inv_mul_cancel two_ne_zero, one_mul]
      gcongr
      norm_num
    simp only [this, and_true]
    rw [pow_add, pow_one, mul_inv, mul_comm _ 2⁻¹, ← mul_assoc, mul_comm _ 2⁻¹, ← mul_assoc,
      inv_mul_cancel two_ne_zero, one_mul]
  | inr h =>
    simp only [IcoPowTwo, inv_pow, mem_Ico, Int.cast_mul, Int.int_cast_ofNat, Int.cast_add,
      Int.cast_one, mem_union, not_lt.mpr h, and_false, h, true_and, false_or]
    have : k * (2 ^ n)⁻¹ ≤ x := by
      refine le_trans ?_ h
      rw [pow_add, pow_one, mul_inv, mul_comm _ 2⁻¹, ← mul_assoc, mul_comm _ 2⁻¹, mul_add,
        ← mul_assoc, inv_mul_cancel two_ne_zero, mul_one, one_mul, add_mul]
      simp only [le_add_iff_nonneg_right, gt_iff_lt, inv_pos, zero_lt_two,
        mul_nonneg_iff_of_pos_left, inv_nonneg]
      positivity
    simp only [this, true_and]
    rw [pow_add, pow_one, mul_inv, mul_comm _ 2⁻¹, ← mul_assoc, mul_comm _ 2⁻¹, add_assoc]
    norm_num
    rw [one_div, mul_add, ← mul_assoc, inv_mul_cancel two_ne_zero, one_mul]

noncomputable def indexIcoPowTwo (n : ℕ) (t : ℝ) : ℤ := Int.floor (t * 2 ^ n)

lemma mem_IcoPowTwo_indexIcoPowTwo (n : ℕ) (t : ℝ) : t ∈ IcoPowTwo n (indexIcoPowTwo n t) := by
  rw [indexIcoPowTwo, IcoPowTwo]
  simp only [inv_pow, mem_Ico]
  constructor
  · rw [← div_eq_mul_inv, div_le_iff]
    · exact Int.floor_le (t * 2 ^ n)
    · positivity
  · rw [← div_eq_mul_inv, lt_div_iff]
    · exact Int.lt_floor_add_one (t * 2 ^ n)
    · positivity

lemma indexIcoPowTwo_of_mem (n : ℕ) (k : ℤ) (t : ℝ) (ht : t ∈ IcoPowTwo n k) :
    indexIcoPowTwo n t = k := by
  rw [indexIcoPowTwo]
  simp only [IcoPowTwo, inv_pow, mem_Ico, ← div_eq_mul_inv] at ht
  rw [div_le_iff, lt_div_iff] at ht
  · rw [Int.floor_eq_iff]
    exact ht
  · positivity
  · positivity

lemma mem_IcoPowTwo_iff_indexIcoPowTwo (n : ℕ) (k : ℤ) (t : ℝ) :
    t ∈ IcoPowTwo n k ↔ indexIcoPowTwo n t = k :=
  ⟨fun h ↦ indexIcoPowTwo_of_mem n k t h, fun h ↦ h ▸ mem_IcoPowTwo_indexIcoPowTwo n t⟩

lemma iUnion_IcoPowTwo (n : ℕ) : ⋃ k, IcoPowTwo n k = univ := by
  ext x
  simp only [mem_iUnion, mem_univ, iff_true]
  exact ⟨indexIcoPowTwo n x, mem_IcoPowTwo_indexIcoPowTwo n x⟩

lemma indexIcoPowTwo_le_indexIcoPowTwo_iff (n : ℕ) (t x : ℝ) :
    indexIcoPowTwo n t ≤ indexIcoPowTwo n x ↔ ⌊t * 2 ^ n⌋ * (2 ^ n)⁻¹ ≤ x := by
  simp only [indexIcoPowTwo]
  rw [← div_eq_mul_inv, div_le_iff, Int.le_floor]
  positivity

lemma iUnion_ge_IcoPowTwo (n : ℕ) (t : ℝ) :
    ⋃ (k) (_ : indexIcoPowTwo n t ≤ k), IcoPowTwo n k = Ici (⌊t * 2 ^ n⌋ * (2 ^ n)⁻¹ : ℝ) := by
  ext x
  simp [mem_IcoPowTwo_iff_indexIcoPowTwo, indexIcoPowTwo_le_indexIcoPowTwo_iff]

lemma iInter_biUnion_I (x : ℝ) :
    ⋂ n, ⋃ (k) (_ : indexIcoPowTwo n x ≤ k), IcoPowTwo n k = Ici x := by
  ext t
  simp [iUnion_ge_IcoPowTwo]
  refine ⟨fun h ↦ ?_, fun h n ↦ le_trans ?_ h⟩
  · by_contra h_lt
    push_neg at h_lt
    have h_pos : ∀ i, 0 < (2 : ℝ) ^ i := fun i ↦ by positivity
    simp_rw [← div_eq_mul_inv, div_le_iff (h_pos _)] at h
    obtain ⟨i, hi⟩ : ∃ i, 1 < (x - t) * 2 ^ i := by
      suffices ∃ i : ℝ, 1 ≤ (x - t) * 2 ^ i by
        obtain ⟨i, hi⟩ := this
        refine ⟨⌈i⌉₊ + 1, hi.trans_lt ?_⟩
        gcongr
        · simp [h_lt]
        · refine ((Real.rpow_lt_rpow_left_iff one_lt_two).mpr (?_ : i < ⌈i⌉₊ + 1)).trans_eq ?_
          · refine (Nat.le_ceil _).trans_lt ?_
            norm_num
          · norm_cast
      use Real.logb 2 ((x - t)⁻¹)
      rw [Real.rpow_logb]
      · rw [mul_inv_cancel]
        rw [sub_ne_zero]
        exact h_lt.ne'
      · exact zero_lt_two
      · simp
      · simp [h_lt]
    specialize h i
    rw [mul_comm, mul_sub, lt_sub_iff_add_lt', mul_comm] at hi
    have h' : ⌈x * 2 ^ i⌉ ≤ t * 2 ^ i + 1 := by
      calc (⌈x * 2 ^ i⌉ : ℝ) ≤ ⌊x * 2 ^ i⌋ + 1 := by
            exact mod_cast (Int.ceil_le_floor_add_one (x * 2 ^ i))
      _ ≤ t * 2 ^ i + 1 := by gcongr
    have h'' : ↑⌈x * 2 ^ i⌉ < 2 ^ i * x := h'.trans_lt hi
    rw [← not_le, mul_comm] at h''
    exact h'' (Int.le_ceil _)
  · rw [← div_eq_mul_inv, div_le_iff]
    · exact Int.floor_le (x * 2 ^ n)
    · positivity

-- todo : `Filtration` should be renamed to `filtration`
def ℱ : Filtration ℕ (borel ℝ) where
  seq := fun n ↦ MeasurableSpace.generateFrom {s | ∃ k, s = IcoPowTwo n k}
  mono' := by
    refine monotone_nat_of_le_succ ?_
    intro n
    refine MeasurableSpace.generateFrom_le fun s ⟨k, hs⟩ ↦ ?_
    rw [hs, ← IcoPowTwo_succ_union n k]
    refine MeasurableSet.union ?_ ?_
    · exact MeasurableSpace.measurableSet_generateFrom ⟨2 * k, rfl⟩
    · exact MeasurableSpace.measurableSet_generateFrom ⟨2 * k + 1, rfl⟩
  le' := fun n ↦ by
    refine MeasurableSpace.generateFrom_le fun s ⟨k, hs⟩ ↦ ?_
    rw [hs]
    exact measurableSet_IcoPowTwo n k

lemma measurableSet_ℱ_IcoPowTwo (n : ℕ) (k : ℤ) : MeasurableSet[ℱ n] (IcoPowTwo n k) :=
  MeasurableSpace.measurableSet_generateFrom ⟨k, rfl⟩

lemma measurable_indexIcoPowTwo (n : ℕ) : Measurable[ℱ n] (indexIcoPowTwo n) := by
  refine @measurable_to_countable' ℤ ℝ _ _ (ℱ n) _ (fun k ↦ ?_)
  have : (fun t ↦ ⌊t * (2 : ℝ) ^ n⌋) ⁻¹' {k} = IcoPowTwo n k := by
    ext t
    simp only [mem_IcoPowTwo_iff_floor, mem_preimage, mem_singleton_iff]
  unfold indexIcoPowTwo
  rw [this]
  exact measurableSet_ℱ_IcoPowTwo n k

lemma iSup_ℱ : ⨆ n, ℱ n = borel ℝ := by
  refine le_antisymm ?_ ?_
  · rw [iSup_le_iff]
    exact ℱ.le
  · conv_lhs => rw [borel_eq_generateFrom_Ici ℝ]
    refine MeasurableSpace.generateFrom_le (fun s ⟨x, hx⟩ ↦ ?_)
    rw [← hx, ← iInter_biUnion_I x]
    refine MeasurableSet.iInter (fun n ↦ ?_)
    refine MeasurableSet.biUnion ?_ (fun k _ ↦ ?_)
    · exact to_countable _
    · exact le_iSup ℱ n _ (measurableSet_ℱ_IcoPowTwo n k)

end dissection_system

variable [MeasurableSpace β]

section DensityProcess

variable {κ : kernel α (ℝ × β)} {ν : kernel α ℝ}

noncomputable
def densityProcess (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (n : ℕ) (a : α) (t : ℝ) (s : Set β) :
    ℝ :=
  (κ a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s) / ν a (IcoPowTwo n (indexIcoPowTwo n t))).toReal

lemma densityProcess_def (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (n : ℕ) (a : α) (s : Set β) :
    (fun t ↦ densityProcess κ ν n a t s)
      = fun t ↦ (κ a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s)
        / ν a (IcoPowTwo n (indexIcoPowTwo n t))).toReal :=
  rfl

lemma measurable_densityProcess_aux (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (n : ℕ)
    {s : Set β} (hs : MeasurableSet s) :
    Measurable (fun (p : α × ℝ) ↦ κ p.1 (IcoPowTwo n (indexIcoPowTwo n p.2) ×ˢ s)
      / ν p.1 (IcoPowTwo n (indexIcoPowTwo n p.2))) := by
  change Measurable ((fun (p : α × ℤ) ↦ κ p.1 (IcoPowTwo n p.2 ×ˢ s) / ν p.1 (IcoPowTwo n p.2))
    ∘ (fun (p : α × ℝ) ↦ (p.1, indexIcoPowTwo n p.2)))
  have h1 :
      Measurable (fun (p : α × ℤ) ↦ κ p.1 (IcoPowTwo n p.2 ×ˢ s) / ν p.1 (IcoPowTwo n p.2)) := by
    refine Measurable.div ?_ ?_
    · have h_swap : Measurable fun (p : ℤ × α) ↦ κ p.2 (IcoPowTwo n p.1 ×ˢ s) := by
        refine measurable_uncurry_of_continuous_of_measurable
          (u := fun k a ↦ κ a (IcoPowTwo n k ×ˢ s)) ?_ ?_
        · exact fun _ ↦ continuous_bot
        · exact fun _ ↦ kernel.measurable_coe _ ((measurableSet_IcoPowTwo _ _).prod hs)
      change Measurable ((fun (p : ℤ × α) ↦ κ p.2 (IcoPowTwo n p.1 ×ˢ s)) ∘ Prod.swap)
      exact h_swap.comp measurable_swap
    · have h_swap : Measurable fun (p : ℤ × α) ↦ ν p.2 (IcoPowTwo n p.1) := by
        refine measurable_uncurry_of_continuous_of_measurable
          (u := fun k a ↦ ν a (IcoPowTwo n k)) ?_ ?_
        · exact fun _ ↦ continuous_bot
        · exact fun _ ↦ kernel.measurable_coe _ (measurableSet_IcoPowTwo _ _)
      change Measurable ((fun (p : ℤ × α) ↦ ν p.2 (IcoPowTwo n p.1)) ∘ Prod.swap)
      exact h_swap.comp measurable_swap
  refine h1.comp (measurable_fst.prod_mk ?_)
  exact (Measurable.mono (measurable_indexIcoPowTwo n) (ℱ.le n) le_rfl).comp measurable_snd

lemma measurable_densityProcess (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (n : ℕ)
    {s : Set β} (hs : MeasurableSet s) :
    Measurable (fun (p : α × ℝ) ↦ densityProcess κ ν n p.1 p.2 s) :=
  (measurable_densityProcess_aux κ ν n hs).ennreal_toReal

lemma measurable_densityProcess_left (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (n : ℕ)
    (t : ℝ) {s : Set β} (hs : MeasurableSet s) :
    Measurable (fun a ↦ densityProcess κ ν n a t s) :=
  (measurable_densityProcess κ ν n hs).comp (measurable_id.prod_mk measurable_const)

lemma measurable_densityProcess_right (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (n : ℕ)
    {s : Set β} (a : α) (hs : MeasurableSet s) :
    Measurable (fun t ↦ densityProcess κ ν n a t s) :=
  (measurable_densityProcess κ ν n hs).comp (measurable_const.prod_mk measurable_id)

lemma measurable_ℱ_densityProcess (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (n : ℕ)
    (a : α) (s : Set β) :
    Measurable[ℱ n] (fun t ↦ densityProcess κ ν n a t s) := by
  rw [densityProcess_def]
  refine @Measurable.ennreal_toReal _ (ℱ n) _ ?_
  refine Measurable.div ?_ ?_
  · change Measurable[ℱ n] ((fun k ↦ κ a (IcoPowTwo n k ×ˢ s)) ∘ (indexIcoPowTwo n))
    refine Measurable.comp ?_ (measurable_indexIcoPowTwo n)
    exact measurable_of_countable _
  · change Measurable[ℱ n] ((fun k ↦ ν a (IcoPowTwo n k)) ∘ (indexIcoPowTwo n))
    refine Measurable.comp ?_ (measurable_indexIcoPowTwo n)
    exact measurable_of_countable _

lemma stronglyMeasurable_ℱ_densityProcess (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (n : ℕ)
    (a : α) (s : Set β) :
    StronglyMeasurable[ℱ n] (fun t ↦ densityProcess κ ν n a t s) :=
  (measurable_ℱ_densityProcess κ ν n a s).stronglyMeasurable

lemma adapted_densityProcess (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (a : α) (s : Set β) :
    Adapted ℱ (fun n t ↦ densityProcess κ ν n a t s) :=
  fun n ↦ stronglyMeasurable_ℱ_densityProcess κ ν n a s

lemma densityProcess_nonneg (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (n : ℕ)
    (a : α) (t : ℝ) (s : Set β) :
    0 ≤ densityProcess κ ν n a t s :=
  ENNReal.toReal_nonneg

lemma apply_IcoPowTwo_le_of_fst_le (hκν : kernel.fst κ ≤ ν) (n : ℕ) (a : α) (t : ℝ) (s : Set β) :
    κ a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s) ≤ ν a (IcoPowTwo n (indexIcoPowTwo n t)) := by
  calc κ a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s)
    ≤ kernel.fst κ a (IcoPowTwo n (indexIcoPowTwo n t)) := by
        rw [kernel.fst_apply' _ _ (measurableSet_IcoPowTwo _ _)]
        refine measure_mono (fun x ↦ ?_)
        simp only [mem_prod, mem_setOf_eq, and_imp]
        exact fun h _ ↦ h
  _ ≤ ν a (IcoPowTwo n (indexIcoPowTwo n t)) := hκν a _ (measurableSet_IcoPowTwo _ _)

lemma densityProcess_le_one (hκν : kernel.fst κ ≤ ν) (n : ℕ) (a : α) (t : ℝ) (s : Set β) :
    densityProcess κ ν n a t s ≤ 1 := by
  refine ENNReal.toReal_le_of_le_ofReal zero_le_one (ENNReal.div_le_of_le_mul ?_)
  rw [ENNReal.ofReal_one, one_mul]
  exact apply_IcoPowTwo_le_of_fst_le hκν n a t s

lemma snorm_densityProcess_le (hκν : kernel.fst κ ≤ ν) (n : ℕ) (a : α) (s : Set β) :
    snorm (fun t ↦ densityProcess κ ν n a t s) 1 (ν a) ≤ ν a univ := by
  refine (snorm_le_of_ae_bound (C := 1) (ae_of_all _ (fun x ↦ ?_))).trans ?_
  · simp only [Real.norm_eq_abs, abs_of_nonneg (densityProcess_nonneg κ ν n a x s),
      densityProcess_le_one hκν n a x s]
  · simp

lemma integrable_densityProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel ν] (n : ℕ)
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    Integrable (fun t ↦ densityProcess κ ν n a t s) (ν a) := by
  rw [← memℒp_one_iff_integrable]
  refine ⟨Measurable.aestronglyMeasurable ?_, ?_⟩
  · exact measurable_densityProcess_right κ ν n a hs
  · exact (snorm_densityProcess_le hκν n a s).trans_lt (measure_lt_top _ _)

lemma set_integral_densityProcess_I (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (n : ℕ) (a : α) {s : Set β} (hs : MeasurableSet s) (k : ℤ) :
    ∫ t in IcoPowTwo n k, densityProcess κ ν n a t s ∂(ν a)
      = (κ a (IcoPowTwo n k ×ˢ s)).toReal := by
  simp_rw [densityProcess]
  rw [integral_toReal]
  rotate_left
  · refine Measurable.aemeasurable ?_
    have h := measurable_densityProcess_aux κ ν n hs
    change Measurable ((fun (p : α × ℝ) ↦ κ p.1 (IcoPowTwo n (indexIcoPowTwo n p.2) ×ˢ s)
      / ν p.1 (IcoPowTwo n (indexIcoPowTwo n p.2))) ∘ (fun t ↦ (a, t)))
    exact h.comp measurable_prod_mk_left
  · refine ae_of_all _ (fun t ↦ ?_)
    by_cases h0 : ν a (IcoPowTwo n (indexIcoPowTwo n t)) = 0
    · suffices κ a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s) = 0 by simp [h0, this]
      have h0' : kernel.fst κ a (IcoPowTwo n (indexIcoPowTwo n t)) = 0 :=
        le_antisymm ((hκν a _ (measurableSet_IcoPowTwo _ _)).trans h0.le) zero_le'
      rw [kernel.fst_apply' _ _ (measurableSet_IcoPowTwo _ _)] at h0'
      refine measure_mono_null (fun x ↦ ?_) h0'
      simp only [mem_prod, mem_setOf_eq, and_imp]
      exact fun h _ ↦ h
    · refine ENNReal.div_lt_top ?_ h0
      exact measure_ne_top _ _
  congr
  have : ∫⁻ t in IcoPowTwo n k,
        κ a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s) / ν a (IcoPowTwo n (indexIcoPowTwo n t)) ∂(ν a)
      = ∫⁻ _ in IcoPowTwo n k, κ a (IcoPowTwo n k ×ˢ s) / ν a (IcoPowTwo n k) ∂(ν a) := by
    refine set_lintegral_congr_fun (measurableSet_IcoPowTwo _ _) (ae_of_all _ (fun t ht ↦ ?_))
    rw [indexIcoPowTwo_of_mem _ _ _ ht]
  rw [this]
  simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
  by_cases h0 : ν a (IcoPowTwo n k) = 0
  · simp only [h0, mul_zero]
    have h0' : kernel.fst κ a (IcoPowTwo n k) = 0 :=
      le_antisymm ((hκν a _ (measurableSet_IcoPowTwo _ _)).trans h0.le) zero_le'
    rw [kernel.fst_apply' _ _ (measurableSet_IcoPowTwo _ _)] at h0'
    refine (measure_mono_null ?_ h0').symm
    intro p
    simp only [mem_prod, mem_setOf_eq, and_imp]
    exact fun h _ ↦ h
  rw [div_eq_mul_inv, mul_assoc, ENNReal.inv_mul_cancel h0, mul_one]
  exact measure_ne_top _ _

lemma integral_densityProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (n : ℕ) (a : α) {s : Set β} (hs : MeasurableSet s) :
    ∫ t, densityProcess κ ν n a t s ∂(ν a) = (κ a (univ ×ˢ s)).toReal := by
  rw [← integral_univ, ← iUnion_IcoPowTwo n, iUnion_prod_const, measure_iUnion]
  rotate_left
  · intro i j hij
    simp only [Set.disjoint_prod, disjoint_self, bot_eq_empty]
    exact Or.inl (pairwise_disjoint_IcoPowTwo n hij)
  · exact fun k ↦ (measurableSet_IcoPowTwo n k).prod hs
  rw [integral_iUnion (measurableSet_IcoPowTwo n) (pairwise_disjoint_IcoPowTwo n)
    (integrable_densityProcess hκν n a hs).integrableOn]
  rw [ENNReal.tsum_toReal_eq (fun _ ↦ measure_ne_top _ _)]
  congr with k
  rw [set_integral_densityProcess_I hκν _ _ hs]

lemma set_integral_densityProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (n : ℕ) (a : α) {s : Set β} (hs : MeasurableSet s) {A : Set ℝ} (hA : MeasurableSet[ℱ n] A) :
    ∫ t in A, densityProcess κ ν n a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal := by
  refine MeasurableSpace.induction_on_inter (m := ℱ n) (s := {s | ∃ k, s = IcoPowTwo n k})
    (C := fun A ↦ ∫ t in A, densityProcess κ ν n a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal) rfl
    ?_ ?_ ?_ ?_ ?_ hA
  · rintro s ⟨i, rfl⟩ t ⟨j, rfl⟩ hst
    refine ⟨i, ?_⟩
    suffices i = j by rw [this, inter_self]
    by_contra h_ne
    have h_disj := pairwise_disjoint_IcoPowTwo n h_ne
    rw [nonempty_iff_ne_empty] at hst
    refine hst ?_
    rwa [Function.onFun, disjoint_iff_inter_eq_empty] at h_disj
  · simp
  · rintro _ ⟨k, rfl⟩
    rw [set_integral_densityProcess_I hκν _ _ hs]
  · intro A hA hA_eq
    have hA' : MeasurableSet A := ℱ.le _ _ hA
    have h := integral_add_compl hA' (integrable_densityProcess hκν n a hs)
    rw [hA_eq, integral_densityProcess hκν n a hs] at h
    have : Aᶜ ×ˢ s = univ ×ˢ s \ A ×ˢ s := by
      rw [prod_diff_prod, compl_eq_univ_diff]
      simp
    rw [this, measure_diff (by intro x; simp) (hA'.prod hs) (measure_ne_top (κ a) _),
      ENNReal.toReal_sub_of_le (measure_mono (by intro x; simp)) (measure_ne_top _ _)]
    rw [eq_tsub_iff_add_eq_of_le, add_comm]
    · exact h
    · rw [ENNReal.toReal_le_toReal (measure_ne_top _ _) (measure_ne_top _ _)]
      exact measure_mono (by intro x; simp)
  · intro f hf_disj hf h_eq
    rw [integral_iUnion (fun i ↦ ℱ.le n _ (hf i)) hf_disj
      (integrable_densityProcess hκν _ _ hs).integrableOn]
    simp_rw [h_eq]
    rw [iUnion_prod_const, measure_iUnion _ (fun i ↦ (ℱ.le n _ (hf i)).prod hs)]
    · rw [ENNReal.tsum_toReal_eq]
      exact fun _ ↦ measure_ne_top _ _
    · intro i j hij
      rw [Function.onFun, Set.disjoint_prod]
      exact Or.inl (hf_disj hij)

lemma set_integral_densityProcess_of_le (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] {n m : ℕ} (hnm : n ≤ m) (a : α) {s : Set β} (hs : MeasurableSet s)
    {A : Set ℝ} (hA : MeasurableSet[ℱ n] A) :
    ∫ t in A, densityProcess κ ν m a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal :=
  set_integral_densityProcess hκν m a hs (ℱ.mono hnm A hA)

lemma condexp_densityProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    {i j : ℕ} (hij : i ≤ j) (a : α) {s : Set β} (hs : MeasurableSet s) :
    (ν a)[fun t ↦ densityProcess κ ν j a t s | ℱ i]
      =ᵐ[ν a] fun t ↦ densityProcess κ ν i a t s := by
  symm
  refine ae_eq_condexp_of_forall_set_integral_eq ?_ ?_ ?_ ?_ ?_
  · exact integrable_densityProcess hκν j a hs
  · refine fun t _ _ ↦ Integrable.integrableOn ?_
    exact integrable_densityProcess hκν _ _ hs
  · intro t ht _
    rw [set_integral_densityProcess hκν i a hs ht,
      set_integral_densityProcess_of_le hκν hij a hs ht]
  · exact StronglyMeasurable.aeStronglyMeasurable' (stronglyMeasurable_ℱ_densityProcess κ ν i a s)

lemma martingale_densityProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    Martingale (fun n t ↦ densityProcess κ ν n a t s) ℱ (ν a) :=
  ⟨adapted_densityProcess κ ν a s, fun _ _ h ↦ condexp_densityProcess hκν h a hs⟩

lemma densityProcess_mono_set (hκν : kernel.fst κ ≤ ν) (n : ℕ) (a : α) (t : ℝ)
    {s s' : Set β} (h : s ⊆ s') :
    densityProcess κ ν n a t s ≤ densityProcess κ ν n a t s' := by
  unfold densityProcess
  by_cases h0 : ν a (IcoPowTwo n (indexIcoPowTwo n t)) = 0
  · rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]
    simp
  have h_ne_top : ∀ s, κ a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s)
      / ν a (IcoPowTwo n (indexIcoPowTwo n t)) ≠ ⊤ := by
    intro s
    rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    refine fun h_top ↦ eq_top_mono ?_ h_top
    exact apply_IcoPowTwo_le_of_fst_le hκν n a t s
  rw [ENNReal.toReal_le_toReal]
  · gcongr
    rw [prod_subset_prod_iff]
    simp [subset_rfl, h]
  · exact h_ne_top s
  · exact h_ne_top s'

lemma densityProcess_mono_kernel_left {κ' : kernel α (ℝ × β)} (hκκ' : κ ≤ κ')
    (hκ'ν : kernel.fst κ' ≤ ν) (n : ℕ) (a : α) (t : ℝ) {s : Set β} (hs : MeasurableSet s) :
    densityProcess κ ν n a t s ≤ densityProcess κ' ν n a t s := by
  unfold densityProcess
  by_cases h0 : ν a (IcoPowTwo n (indexIcoPowTwo n t)) = 0
  · rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]
    simp
  have h_le : κ' a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s)
      ≤ ν a (IcoPowTwo n (indexIcoPowTwo n t)) := apply_IcoPowTwo_le_of_fst_le hκ'ν n a t s
  rw [ENNReal.toReal_le_toReal]
  · gcongr
    exact hκκ' _ _ ((measurableSet_IcoPowTwo _ _).prod hs)
  · rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    refine fun h_top ↦ eq_top_mono ?_ h_top
    exact (hκκ' _ _ ((measurableSet_IcoPowTwo _ _).prod hs)).trans h_le
  · rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    exact fun h_top ↦ eq_top_mono h_le h_top

lemma densityProcess_antitone_kernel_right {ν' : kernel α ℝ}
    (hνν' : ν ≤ ν') (hκν : kernel.fst κ ≤ ν) (n : ℕ) (a : α) (t : ℝ) (s : Set β) :
    densityProcess κ ν' n a t s ≤ densityProcess κ ν n a t s := by
  unfold densityProcess
  have h_le : κ a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s)
      ≤ ν a (IcoPowTwo n (indexIcoPowTwo n t)) := apply_IcoPowTwo_le_of_fst_le hκν n a t s
  by_cases h0 : ν a (IcoPowTwo n (indexIcoPowTwo n t)) = 0
  · suffices κ a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s) = 0 by
      simp only [this, ENNReal.zero_div, ENNReal.zero_toReal, h0, le_refl]
    exact le_antisymm (h_le.trans h0.le) zero_le'
  have h0' : ν' a (IcoPowTwo n (indexIcoPowTwo n t)) ≠ 0 := by
    refine fun h ↦ h0 (le_antisymm (le_trans ?_ h.le) zero_le')
    exact hνν' _ _ (measurableSet_IcoPowTwo _ _)
  rw [ENNReal.toReal_le_toReal]
  · gcongr
    exact hνν' _ _ (measurableSet_IcoPowTwo _ _)
  · simp only [ne_eq, ENNReal.div_eq_top, h0', and_false, false_or, not_and, not_not]
    refine fun h_top ↦ eq_top_mono ?_ h_top
    exact h_le.trans (hνν' _ _ (measurableSet_IcoPowTwo _ _))
  · simp only [ne_eq, ENNReal.div_eq_top, h0, and_false, false_or, not_and, not_not]
    exact fun h_top ↦ eq_top_mono h_le h_top

lemma densityProcess_empty (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (n : ℕ) (a : α) (t : ℝ) :
    densityProcess κ ν n a t ∅ = 0 := by
  simp [densityProcess]

lemma tendsto_densityProcess_atTop_empty_of_antitone (κ : kernel α (ℝ × β)) (ν : kernel α ℝ)
    [IsFiniteKernel κ] (n : ℕ) (a : α) (t : ℝ)
    (s : ℕ → Set β) (hs : Antitone s) (hs_iInter : ⋂ i, s i = ∅)
    (hs_meas : ∀ n, MeasurableSet (s n)) :
    Tendsto (fun m ↦ densityProcess κ ν n a t (s m)) atTop (𝓝 (densityProcess κ ν n a t ∅)) := by
  simp_rw [densityProcess]
  by_cases h0 : ν a (IcoPowTwo n (indexIcoPowTwo n t)) = 0
  · simp_rw [h0, ENNReal.toReal_div]
    simp
  refine (ENNReal.tendsto_toReal ?_).comp ?_
  · rw [ne_eq, ENNReal.div_eq_top]
    push_neg
    simp
  refine ENNReal.Tendsto.div_const ?_ ?_
  · have h := tendsto_measure_iInter (μ := κ a)
      (s := fun m ↦ IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s m) ?_ ?_ ?_
    · convert h
      rw [← prod_iInter, hs_iInter]
    · exact fun n ↦ MeasurableSet.prod (measurableSet_IcoPowTwo _ _) (hs_meas n)
    · intro m m' hmm'
      simp only [le_eq_subset, prod_subset_prod_iff, subset_rfl, true_and]
      exact Or.inl <| hs hmm'
    · exact ⟨0, measure_ne_top _ _⟩
  · simp only [prod_empty, OuterMeasure.empty', ne_eq, not_true_eq_false, false_or, h0,
      not_false_iff]

lemma tendsto_densityProcess_atTop_of_antitone (κ : kernel α (ℝ × β)) (ν : kernel α ℝ)
    [IsFiniteKernel κ] (n : ℕ) (a : α) (t : ℝ)
    (s : ℕ → Set β) (hs : Antitone s) (hs_iInter : ⋂ i, s i = ∅)
    (hs_meas : ∀ n, MeasurableSet (s n)) :
    Tendsto (fun m ↦ densityProcess κ ν n a t (s m)) atTop (𝓝 0) := by
  rw [← densityProcess_empty κ ν n a t]
  exact tendsto_densityProcess_atTop_empty_of_antitone κ ν n a t s hs hs_iInter hs_meas

lemma tendsto_densityProcess_limitProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] (a : α) {s : Set β} (hs : MeasurableSet s) :
    ∀ᵐ t ∂(ν a), Tendsto (fun n ↦ densityProcess κ ν n a t s) atTop
      (𝓝 (ℱ.limitProcess (fun n t ↦ densityProcess κ ν n a t s) (ν a) t)) := by
  refine Submartingale.ae_tendsto_limitProcess (martingale_densityProcess hκν a hs).submartingale
    (R := (ν a univ).toNNReal) (fun n ↦ ?_)
  refine (snorm_densityProcess_le hκν n a s).trans_eq ?_
  rw [ENNReal.coe_toNNReal]
  exact measure_ne_top _ _

lemma limitProcess_mem_L1 (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    Memℒp (ℱ.limitProcess (fun n t ↦ densityProcess κ ν n a t s) (ν a)) 1 (ν a) := by
  refine Submartingale.memℒp_limitProcess (martingale_densityProcess hκν a hs).submartingale
    (R := (ν a univ).toNNReal) (fun n ↦ ?_)
  refine (snorm_densityProcess_le hκν n a s).trans_eq ?_
  rw [ENNReal.coe_toNNReal]
  exact measure_ne_top _ _

lemma tendsto_snorm_one_densityProcess_limitProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] (a : α) {s : Set β} (hs : MeasurableSet s) :
    Tendsto (fun n ↦ snorm ((fun t ↦ densityProcess κ ν n a t s)
        - ℱ.limitProcess (fun n t ↦ densityProcess κ ν n a t s) (ν a)) 1 (ν a))
      atTop (𝓝 0) := by
  refine Submartingale.tendsto_snorm_one_limitProcess ?_ ?_
  · exact (martingale_densityProcess hκν a hs).submartingale
  · refine uniformIntegrable_of le_rfl ENNReal.one_ne_top ?_ ?_
    · exact fun n ↦ (measurable_densityProcess_right κ ν n a hs).aestronglyMeasurable
    · intro ε _
      refine ⟨2, fun n ↦ ?_⟩
      refine le_of_eq_of_le ?_ (?_ : 0 ≤ ENNReal.ofReal ε)
      · have : {x | 2 ≤ ‖densityProcess κ ν n a x s‖₊} = ∅ := by
          ext x
          simp only [mem_setOf_eq, mem_empty_iff_false, iff_false, not_le]
          refine (?_ : _ ≤ (1 : ℝ≥0)).trans_lt one_lt_two
          rw [Real.nnnorm_of_nonneg (densityProcess_nonneg _ _ _ _ _ _)]
          exact mod_cast (densityProcess_le_one hκν _ _ _ _)
        rw [this]
        simp
      · simp

lemma tendsto_snorm_one_restrict_densityProcess_limitProcess [IsFiniteKernel κ] [IsFiniteKernel ν]
    (hκν : kernel.fst κ ≤ ν) (a : α) {s : Set β} (hs : MeasurableSet s) (A : Set ℝ) :
    Tendsto (fun n ↦ snorm ((fun t ↦ densityProcess κ ν n a t s)
        - ℱ.limitProcess (fun n t ↦ densityProcess κ ν n a t s) (ν a)) 1 ((ν a).restrict A))
      atTop (𝓝 0) :=
  tendsto_snorm_restrict_zero (tendsto_snorm_one_densityProcess_limitProcess hκν a hs) A

noncomputable
def MLimsup (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (a : α) (t : ℝ) (s : Set β) : ℝ :=
  limsup (fun n ↦ densityProcess κ ν n a t s) atTop

lemma mLimsup_ae_eq_limitProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    (fun t ↦ MLimsup κ ν a t s)
      =ᵐ[ν a] ℱ.limitProcess (fun n t ↦ densityProcess κ ν n a t s) (ν a) := by
  filter_upwards [tendsto_densityProcess_limitProcess hκν a hs] with t ht using ht.limsup_eq

lemma tendsto_m_mLimsup (hκν : kernel.fst κ ≤ ν) (a : α) [IsFiniteKernel κ] [IsFiniteKernel ν]
    {s : Set β} (hs : MeasurableSet s) :
    ∀ᵐ t ∂(ν a),
      Tendsto (fun n ↦ densityProcess κ ν n a t s) atTop (𝓝 (MLimsup κ ν a t s)) := by
  filter_upwards [tendsto_densityProcess_limitProcess hκν a hs, mLimsup_ae_eq_limitProcess hκν a hs]
    with t h1 h2 using h2 ▸ h1

lemma measurable_mLimsup (κ : kernel α (ℝ × β)) (ν : kernel α ℝ)
    {s : Set β} (hs : MeasurableSet s) :
    Measurable (fun (p : α × ℝ) ↦ MLimsup κ ν p.1 p.2 s) :=
  measurable_limsup (fun n ↦ measurable_densityProcess κ ν n hs)

lemma measurable_mLimsup_left (κ : kernel α (ℝ × β)) (ν : kernel α ℝ) (t : ℝ)
    {s : Set β} (hs : MeasurableSet s) :
    Measurable (fun a ↦ MLimsup κ ν a t s) := by
  change Measurable ((fun (p : α × ℝ) ↦ MLimsup κ ν p.1 p.2 s) ∘ (fun a ↦ (a, t)))
  exact (measurable_mLimsup κ ν hs).comp measurable_prod_mk_right

lemma measurable_mLimsup_right (κ : kernel α (ℝ × β)) (ν : kernel α ℝ)
    {s : Set β} (hs : MeasurableSet s) (a : α) :
    Measurable (fun t ↦ MLimsup κ ν a t s) := by
  change Measurable ((fun (p : α × ℝ) ↦ MLimsup κ ν p.1 p.2 s) ∘ (fun t ↦ (a, t)))
  exact (measurable_mLimsup κ ν hs).comp measurable_prod_mk_left

lemma mLimsup_mono_set (hκν : kernel.fst κ ≤ ν) (a : α) (t : ℝ) {s s' : Set β} (h : s ⊆ s') :
    MLimsup κ ν a t s ≤ MLimsup κ ν a t s' := by
  refine limsup_le_limsup ?_ ?_ ?_
  · exact eventually_of_forall (fun n ↦ densityProcess_mono_set hκν n a t h)
  · exact isCoboundedUnder_le_of_le atTop (fun i ↦ densityProcess_nonneg _ _ _ _ _ _)
  · exact isBoundedUnder_of ⟨1, fun n ↦ densityProcess_le_one hκν _ _ _ _⟩

lemma mLimsup_nonneg (hκν : kernel.fst κ ≤ ν) (a : α) (t : ℝ) (s : Set β) :
    0 ≤ MLimsup κ ν a t s := by
  refine le_limsup_of_frequently_le ?_ ?_
  · exact frequently_of_forall (fun n ↦ densityProcess_nonneg _ _ _ _ _ _)
  · exact isBoundedUnder_of ⟨1, fun n ↦ densityProcess_le_one hκν _ _ _ _⟩

lemma mLimsup_le_one (hκν : kernel.fst κ ≤ ν) (a : α) (t : ℝ) (s : Set β) :
    MLimsup κ ν a t s ≤ 1 := by
  refine limsup_le_of_le ?_ ?_
  · exact isCoboundedUnder_le_of_le atTop (fun i ↦ densityProcess_nonneg _ _ _ _ _ _)
  · exact eventually_of_forall (fun n ↦ densityProcess_le_one hκν _ _ _ _)

lemma snorm_mLimsup_le (hκν : kernel.fst κ ≤ ν) (a : α) (s : Set β) :
    snorm (fun t ↦ MLimsup κ ν a t s) 1 (ν a) ≤ ν a univ := by
  refine (snorm_le_of_ae_bound (C := 1) (ae_of_all _ (fun t ↦ ?_))).trans ?_
  · simp only [Real.norm_eq_abs, abs_of_nonneg (mLimsup_nonneg hκν a t s),
      mLimsup_le_one hκν a t s]
  · simp

lemma integrable_mLimsup (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    Integrable (fun t ↦ MLimsup κ ν a t s) (ν a) := by
  rw [← memℒp_one_iff_integrable]
  refine ⟨Measurable.aestronglyMeasurable ?_, ?_⟩
  · exact measurable_mLimsup_right κ ν hs a
  · exact (snorm_mLimsup_le hκν a s).trans_lt (measure_lt_top _ _)

lemma tendsto_set_integral_m (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) (A : Set ℝ) :
    Tendsto (fun i ↦ ∫ x in A, densityProcess κ ν i a x s ∂(ν a)) atTop
      (𝓝 (∫ x in A, MLimsup κ ν a x s ∂(ν a))) := by
  refine tendsto_set_integral_of_L1' (μ := ν a) (fun t ↦ MLimsup κ ν a t s)
    (integrable_mLimsup hκν a hs) (F := fun i t ↦ densityProcess κ ν i a t s) (l := atTop)
    (eventually_of_forall (fun n ↦ integrable_densityProcess hκν _ _ hs)) ?_ A
  refine (tendsto_congr fun n ↦ ?_).mp (tendsto_snorm_one_densityProcess_limitProcess hκν a hs)
  refine snorm_congr_ae ?_
  exact EventuallyEq.rfl.sub (mLimsup_ae_eq_limitProcess hκν a hs).symm

/-- Auxiliary lemma for `set_integral_mLimsup`. -/
lemma set_integral_mLimsup_of_measurableSet (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν]
    (n : ℕ) (a : α) {s : Set β} (hs : MeasurableSet s) {A : Set ℝ} (hA : MeasurableSet[ℱ n] A) :
    ∫ t in A, MLimsup κ ν a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal := by
  suffices ∫ t in A, MLimsup κ ν a t s ∂(ν a) = ∫ t in A, densityProcess κ ν n a t s ∂(ν a) by
    rw [this]
    exact set_integral_densityProcess hκν _ _ hs hA
  suffices ∫ t in A, MLimsup κ ν a t s ∂(ν a)
      = limsup (fun i ↦ ∫ t in A, densityProcess κ ν i a t s ∂(ν a)) atTop by
    rw [this, ← limsup_const (α := ℕ) (f := atTop) (∫ t in A, densityProcess κ ν n a t s ∂(ν a)),
      limsup_congr]
    simp only [eventually_atTop, ge_iff_le]
    refine ⟨n, fun m hnm ↦ ?_⟩
    rw [set_integral_densityProcess_of_le hκν hnm _ hs hA,
      set_integral_densityProcess hκν _ _ hs hA]
  -- use L1 convergence
  have h := tendsto_set_integral_m hκν a hs A
  rw [h.limsup_eq]

lemma integral_mLimsup (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    ∫ t, MLimsup κ ν a t s ∂(ν a) = (κ a (univ ×ˢ s)).toReal := by
  rw [← integral_univ, set_integral_mLimsup_of_measurableSet hκν 0 a hs MeasurableSet.univ]

lemma set_integral_mLimsup (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) {A : Set ℝ} (hA : MeasurableSet A) :
    ∫ t in A, MLimsup κ ν a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal := by
  have hA' : MeasurableSet[⨆ n, ℱ n] A := by rwa [iSup_ℱ]
  refine MeasurableSpace.induction_on_inter (m := ⨆ n, ℱ n)
    (C := fun A ↦ ∫ t in A, MLimsup κ ν a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal)
    (MeasurableSpace.measurableSpace_iSup_eq ℱ) ?_ ?_ ?_ ?_ ?_ hA'
  · rintro s ⟨n, hs⟩ t ⟨m, ht⟩ _
    exact ⟨max n m, (ℱ.mono (le_max_left n m) _ hs).inter (ℱ.mono (le_max_right n m) _ ht)⟩
  · simp
  · intro A ⟨n, hA⟩
    exact set_integral_mLimsup_of_measurableSet hκν n a hs hA
  · intro A hA hA_eq
    rw [iSup_ℱ] at hA
    have h := integral_add_compl hA (integrable_mLimsup hκν a hs)
    rw [hA_eq, integral_mLimsup hκν a hs] at h
    have : Aᶜ ×ˢ s = univ ×ˢ s \ A ×ˢ s := by
      rw [prod_diff_prod, compl_eq_univ_diff]
      simp
    rw [this, measure_diff (by intro x; simp) (hA.prod hs) (measure_ne_top (κ a) _),
      ENNReal.toReal_sub_of_le (measure_mono (by intro x; simp)) (measure_ne_top _ _)]
    rw [eq_tsub_iff_add_eq_of_le, add_comm]
    · exact h
    · rw [ENNReal.toReal_le_toReal (measure_ne_top _ _) (measure_ne_top _ _)]
      exact measure_mono (by intro x; simp)
  · intro f hf_disj hf h_eq
    rw [integral_iUnion _ hf_disj (integrable_mLimsup hκν _ hs).integrableOn]
    · simp_rw [h_eq]
      rw [← ENNReal.tsum_toReal_eq (fun _ ↦ measure_ne_top _ _)]
      congr
      rw [iUnion_prod_const, measure_iUnion]
      · intro i j hij
        rw [Function.onFun, Set.disjoint_prod]
        exact Or.inl (hf_disj hij)
      · rw [iSup_ℱ] at hf
        exact fun i ↦ (hf i).prod hs
    · rwa [iSup_ℱ] at hf

lemma tendsto_integral_mLimsup_of_monotone (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν]
    (a : α) (s : ℕ → Set β) (hs : Monotone s) (hs_iUnion : ⋃ i, s i = univ)
    (hs_meas : ∀ n, MeasurableSet (s n)) :
    Tendsto (fun m ↦ ∫ t, MLimsup κ ν a t (s m) ∂(ν a)) atTop (𝓝 (κ a univ).toReal) := by
  simp_rw [integral_mLimsup hκν a (hs_meas _)]
  have h_cont := ENNReal.continuousOn_toReal.continuousAt (x := κ a univ) ?_
  swap
  · rw [mem_nhds_iff]
    refine ⟨Iio (κ a univ + 1), fun x hx ↦ ne_top_of_lt (?_ : x < κ a univ + 1), isOpen_Iio, ?_⟩
    · simpa using hx
    · simp only [mem_Iio]
      exact ENNReal.lt_add_right (measure_ne_top _ _) one_ne_zero
  refine h_cont.tendsto.comp ?_
  have h := tendsto_measure_iUnion (s := fun n ↦ univ ×ˢ s n) (μ := κ a) ?_
  swap; · intro n m hnm x; simp only [mem_prod, mem_univ, true_and]; exact fun h ↦ hs hnm h
  convert h
  rw [← prod_iUnion, hs_iUnion]
  simp only [univ_prod_univ, measure_univ]

lemma tendsto_integral_mLimsup_of_antitone (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν]
    (a : α) (s : ℕ → Set β) (hs : Antitone s) (hs_iInter : ⋂ i, s i = ∅)
    (hs_meas : ∀ n, MeasurableSet (s n)) :
    Tendsto (fun m ↦ ∫ t, MLimsup κ ν a t (s m) ∂(ν a)) atTop (𝓝 0) := by
  simp_rw [integral_mLimsup hκν a (hs_meas _)]
  rw [← ENNReal.zero_toReal]
  have h_cont := ENNReal.continuousOn_toReal.continuousAt (x := 0) ?_
  swap
  · rw [mem_nhds_iff]
    refine ⟨Iio 1, fun x hx ↦ ne_top_of_lt (?_ : x < 1), isOpen_Iio, ?_⟩
    · simpa using hx
    · simp
  refine h_cont.tendsto.comp ?_
  have h := tendsto_measure_iInter (s := fun n ↦ univ ×ˢ s n) (μ := κ a)
    (fun n ↦ MeasurableSet.univ.prod (hs_meas n)) ?_ ?_
  rotate_left
  · intro n m hnm x; simp only [mem_prod, mem_univ, true_and]; exact fun h ↦ hs hnm h
  · refine ⟨0, measure_ne_top _ _⟩
  convert h
  rw [← prod_iInter, hs_iInter]
  simp only [ne_eq, prod_empty, OuterMeasure.empty', forall_exists_index]

lemma tendsto_mLimsup_atTop_ae_of_antitone (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] (a : α) (s : ℕ → Set β) (hs : Antitone s) (hs_iInter : ⋂ i, s i = ∅)
    (hs_meas : ∀ n, MeasurableSet (s n)) :
    ∀ᵐ t ∂(ν a), Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 0) := by
  have h_anti : ∀ t, Antitone (fun m ↦ MLimsup κ ν a t (s m)) :=
    fun t n m hnm ↦ mLimsup_mono_set hκν a t (hs hnm)
  have h_le_one : ∀ m t, MLimsup κ ν a t (s m) ≤ 1 := fun m t ↦ mLimsup_le_one hκν a t (s m)
  -- for all `t`, `fun m ↦ MLimsup κ a (s m) t` has a limit
  have h_exists : ∀ t, ∃ l, Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 l) := by
    intro t
    have h_tendsto : Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop atBot ∨
        ∃ l, Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 l) :=
      tendsto_of_antitone (h_anti t)
    cases' h_tendsto with h_absurd h_tendsto
    · rw [tendsto_atTop_atBot_iff_of_antitone (h_anti t)] at h_absurd
      obtain ⟨r, hr⟩ := h_absurd (-1)
      have h_nonneg := mLimsup_nonneg hκν a t (s r)
      linarith
    · exact h_tendsto
  -- let `F` be the pointwise limit of `fun m ↦ MLimsup κ a (s m) t` for all `t`
  let F : ℝ → ℝ := fun t ↦ (h_exists t).choose
  have hF_tendsto : ∀ t, Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 (F t)) :=
    fun t ↦ (h_exists t).choose_spec
  have hF_nonneg : ∀ t, 0 ≤ F t :=
    fun t ↦ ge_of_tendsto' (hF_tendsto t) (fun m ↦ mLimsup_nonneg hκν a t (s m))
  have hF_le_one : ∀ t, F t ≤ 1 := fun t ↦ le_of_tendsto' (hF_tendsto t) (fun m ↦ h_le_one m t)
  have hF_int : Integrable F (ν a) := by
    rw [← memℒp_one_iff_integrable]
    refine ⟨?_, ?_⟩
    · refine aestronglyMeasurable_of_tendsto_ae atTop (fun n ↦ ?_) (ae_of_all _ hF_tendsto)
      exact (measurable_mLimsup_right κ ν (hs_meas _) a).aestronglyMeasurable
    · rw [snorm_one_eq_lintegral_nnnorm]
      calc ∫⁻ x, ‖F x‖₊ ∂(ν a) ≤ ∫⁻ _, 1 ∂(ν a) := by
            refine lintegral_mono (fun x ↦ ?_)
            rw [← ofReal_norm_eq_coe_nnnorm, Real.norm_eq_abs, ENNReal.ofReal_le_one,
              abs_of_nonneg (hF_nonneg _)]
            exact hF_le_one _
      _ < ⊤ := by
            simp only [lintegral_const, one_mul]
            exact measure_lt_top _ _
   -- it suffices to show that the limit `F` is 0 a.e.
  suffices ∀ᵐ t ∂(ν a), F t = 0 by
    filter_upwards [this] with t ht_eq
    rw [← ht_eq]
    exact hF_tendsto t
  -- since `F` is nonnegative, proving that its integral is 0 is sufficient to get that
  -- `F` is 0 a.e.
  suffices ∀ᵐ (t : ℝ) ∂(ν a), 0 = F t by filter_upwards [this] with a ha; simp [ha]
  refine ae_eq_of_integral_eq_of_ae_le (integrable_const _) hF_int  (ae_of_all _ hF_nonneg) ?_
  have h_integral :
      Tendsto (fun m : ℕ ↦ ∫ t, MLimsup κ ν a t (s m) ∂(ν a)) atTop (𝓝 (∫ t, F t ∂(ν a))) := by
    refine integral_tendsto_of_tendsto_of_antitone ?_ hF_int ?_ ?_
    · exact fun n ↦ integrable_mLimsup hκν _ (hs_meas n)
    · exact ae_of_all _ h_anti
    · exact ae_of_all _ hF_tendsto
  have h_integral' :
      Tendsto (fun m : ℕ ↦ ∫ t, MLimsup κ ν a t (s m) ∂(ν a)) atTop (𝓝 (∫ _, 0 ∂(ν a))) := by
    simp only [integral_zero]
    exact tendsto_integral_mLimsup_of_antitone hκν a s hs hs_iInter hs_meas
  exact (tendsto_nhds_unique h_integral h_integral').symm

section UnivFst

lemma densityProcess_univ [IsFiniteKernel κ] (n : ℕ) (a : α) (t : ℝ) :
    densityProcess κ (kernel.fst κ) n a t univ
      = if kernel.fst κ a (IcoPowTwo n (indexIcoPowTwo n t)) = 0 then 0 else 1 := by
  rw [densityProcess]
  by_cases h : kernel.fst κ a (IcoPowTwo n (indexIcoPowTwo n t)) = 0
  · simp [h]
    by_cases h' : κ a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ univ) = 0
    · simp [h']
    · rw [ENNReal.div_zero h']
      simp
  · simp only [h, ite_false]
    rw [kernel.fst_apply' _ _ (measurableSet_IcoPowTwo _ _)]
    have : IcoPowTwo n (indexIcoPowTwo n t) ×ˢ univ
        = {p : ℝ × β | p.1 ∈ IcoPowTwo n (indexIcoPowTwo n t)} := by
      ext x
      simp
    rw [this, ENNReal.div_self]
    · simp
    · rwa [kernel.fst_apply' _ _ (measurableSet_IcoPowTwo _ _)] at h
    · exact measure_ne_top _ _

lemma densityProcess_univ_ae (κ : kernel α (ℝ × β)) [IsFiniteKernel κ] (n : ℕ) (a : α) :
    ∀ᵐ t ∂(kernel.fst κ a), densityProcess κ (kernel.fst κ) n a t univ = 1 := by
  rw [ae_iff]
  have : {t | ¬ densityProcess κ (kernel.fst κ) n a t univ = 1}
      ⊆ {t | kernel.fst κ a (IcoPowTwo n (indexIcoPowTwo n t)) = 0} := by
    intro t ht
    simp only [mem_setOf_eq] at ht ⊢
    rw [densityProcess_univ] at ht
    simpa using ht
  refine measure_mono_null this ?_
  have : {t | kernel.fst κ a (IcoPowTwo n (indexIcoPowTwo n t)) = 0}
      ⊆ ⋃ (k) (_ : kernel.fst κ a (IcoPowTwo n k) = 0), IcoPowTwo n k := by
    intro t ht
    simp only [mem_setOf_eq, mem_iUnion, exists_prop] at ht ⊢
    exact ⟨indexIcoPowTwo n t, ht, mem_IcoPowTwo_indexIcoPowTwo _ _⟩
  refine measure_mono_null this ?_
  rw [measure_iUnion_null]
  simp

lemma tendsto_densityProcess_atTop_univ_of_monotone (κ : kernel α (ℝ × β))
    (n : ℕ) (a : α) (t : ℝ) (s : ℕ → Set β) (hs : Monotone s) (hs_iUnion : ⋃ i, s i = univ) :
    Tendsto (fun m ↦ densityProcess κ (kernel.fst κ) n a t (s m)) atTop
      (𝓝 (densityProcess κ (kernel.fst κ) n a t univ)) := by
  simp_rw [densityProcess]
  refine (ENNReal.tendsto_toReal ?_).comp ?_
  · rw [ne_eq, ENNReal.div_eq_top]
    push_neg
    simp_rw [kernel.fst_apply' _ _ (measurableSet_IcoPowTwo _ _)]
    constructor
    · refine fun h h0 ↦ h (measure_mono_null (fun x ↦ ?_) h0)
      simp only [mem_prod, mem_setOf_eq, and_imp]
      exact fun h _ ↦ h
    · refine fun h_top ↦ eq_top_mono (measure_mono (fun x ↦ ?_)) h_top
      simp only [mem_prod, mem_setOf_eq, and_imp]
      exact fun h _ ↦ h
  by_cases h0 : kernel.fst κ a (IcoPowTwo n (indexIcoPowTwo n t)) = 0
  · rw [kernel.fst_apply' _ _ (measurableSet_IcoPowTwo _ _)] at h0 ⊢
    suffices ∀ m, κ a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s m) = 0 by
      simp only [this, h0, ENNReal.zero_div, tendsto_const_nhds_iff]
      suffices κ a (IcoPowTwo n (indexIcoPowTwo n t) ×ˢ univ) = 0 by
        simp only [this, ENNReal.zero_div]
      convert h0
      ext x
      simp only [mem_prod, mem_univ, and_true, mem_setOf_eq]
    refine fun m ↦ measure_mono_null (fun x ↦ ?_) h0
    simp only [mem_prod, mem_setOf_eq, and_imp]
    exact fun h _ ↦ h
  refine ENNReal.Tendsto.div_const ?_ ?_
  · have h := tendsto_measure_iUnion (μ := κ a)
      (s := fun m ↦ IcoPowTwo n (indexIcoPowTwo n t) ×ˢ s m) ?_
    swap
    · intro m m' hmm'
      simp only [le_eq_subset, prod_subset_prod_iff, subset_rfl, true_and]
      exact Or.inl <| hs hmm'
    convert h
    rw [← prod_iUnion, hs_iUnion]
  · exact Or.inr h0

lemma tendsto_densityProcess_atTop_ae_of_monotone (κ : kernel α (ℝ × β)) [IsFiniteKernel κ]
    (n : ℕ) (a : α) (s : ℕ → Set β) (hs : Monotone s) (hs_iUnion : ⋃ i, s i = univ) :
    ∀ᵐ t ∂(kernel.fst κ a),
      Tendsto (fun m ↦ densityProcess κ (kernel.fst κ) n a t (s m)) atTop (𝓝 1) := by
  filter_upwards [densityProcess_univ_ae κ n a] with t ht
  rw [← ht]
  exact tendsto_densityProcess_atTop_univ_of_monotone κ n a t s hs hs_iUnion

lemma mLimsup_univ (κ : kernel α (ℝ × β)) [IsFiniteKernel κ] (a : α) :
    ∀ᵐ t ∂(kernel.fst κ a), MLimsup κ (kernel.fst κ) a t univ = 1 := by
  have h := fun n ↦ densityProcess_univ_ae κ n a
  rw [← ae_all_iff] at h
  filter_upwards [h] with t ht
  rw [MLimsup]
  simp [ht]

lemma tendsto_mLimsup_atTop_ae_of_monotone [IsFiniteKernel κ]
    (a : α) (s : ℕ → Set β) (hs : Monotone s) (hs_iUnion : ⋃ i, s i = univ)
    (hs_meas : ∀ n, MeasurableSet (s n)) :
    ∀ᵐ t ∂(kernel.fst κ a), Tendsto (fun m ↦ MLimsup κ (kernel.fst κ) a t (s m)) atTop (𝓝 1) := by
  let ν := kernel.fst κ
  have h_mono : ∀ t, Monotone (fun m ↦ MLimsup κ (kernel.fst κ) a t (s m)) :=
    fun t n m hnm ↦ mLimsup_mono_set le_rfl a t (hs hnm)
  have h_le_one : ∀ m t, MLimsup κ ν a t (s m) ≤ 1 := fun m t ↦ mLimsup_le_one le_rfl a t (s m)
  -- for all `t`, `fun m ↦ MLimsup κ a (s m) t` has a limit
  have h_exists : ∀ t, ∃ l, Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 l) := by
    intro t
    have h_tendsto : Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop atTop ∨
        ∃ l, Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 l) :=
      tendsto_of_monotone (h_mono t)
    cases' h_tendsto with h_absurd h_tendsto
    · rw [tendsto_atTop_atTop_iff_of_monotone (h_mono t)] at h_absurd
      obtain ⟨r, hr⟩ := h_absurd 2
      exact absurd (hr.trans (h_le_one r t)) one_lt_two.not_le
    · exact h_tendsto
  -- let `F` be the pointwise limit of `fun m ↦ MLimsup κ a (s m) t` for all `t`
  let F : ℝ → ℝ := fun t ↦ (h_exists t).choose
  have hF_tendsto : ∀ t, Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 (F t)) :=
    fun t ↦ (h_exists t).choose_spec
  have hF_nonneg : ∀ t, 0 ≤ F t :=
    fun t ↦ ge_of_tendsto' (hF_tendsto t) (fun m ↦ mLimsup_nonneg le_rfl a t (s m))
  have hF_le_one : ∀ t, F t ≤ 1 := fun t ↦ le_of_tendsto' (hF_tendsto t) (fun m ↦ h_le_one m t)
  have hF_int : Integrable F (ν a) := by
    rw [← memℒp_one_iff_integrable]
    constructor
    · refine aestronglyMeasurable_of_tendsto_ae atTop (fun n ↦ ?_) (ae_of_all _ hF_tendsto)
      exact (measurable_mLimsup_right κ ν (hs_meas _) a).aestronglyMeasurable
    · rw [snorm_one_eq_lintegral_nnnorm]
      calc ∫⁻ x, ‖F x‖₊ ∂(ν a) ≤ ∫⁻ _, 1 ∂(ν a) := by
            refine lintegral_mono (fun x ↦ ?_)
            rw [← ofReal_norm_eq_coe_nnnorm, Real.norm_eq_abs, ENNReal.ofReal_le_one,
              abs_of_nonneg (hF_nonneg _)]
            exact hF_le_one _
      _ < ⊤ := by simp only [lintegral_const, measure_univ, one_mul, measure_lt_top]
   -- it suffices to show that the limit `F` is 1 a.e.
  suffices ∀ᵐ t ∂(ν a), F t = 1 by
    filter_upwards [this] with t ht_eq
    rw [← ht_eq]
    exact hF_tendsto t
  -- since `F` is at most 1, proving that its integral is the same as the integral of 1 will tell
  -- us that `F` is 1 a.e.
  refine ae_eq_of_integral_eq_of_ae_le hF_int (integrable_const _) (ae_of_all _ hF_le_one) ?_
  have h_integral :
      Tendsto (fun m : ℕ ↦ ∫ t, MLimsup κ ν a t (s m) ∂(ν a)) atTop (𝓝 (∫ t, F t ∂(ν a))) := by
    refine integral_tendsto_of_tendsto_of_monotone ?_ hF_int ?_ ?_
    · exact fun n ↦ integrable_mLimsup le_rfl _ (hs_meas n)
    · exact ae_of_all _ h_mono
    · exact ae_of_all _ hF_tendsto
  have h_integral' :
      Tendsto (fun m : ℕ ↦ ∫ t, MLimsup κ ν a t (s m) ∂(ν a)) atTop (𝓝 (∫ _, 1 ∂(ν a))) := by
    rw [integral_const]
    simp only [smul_eq_mul, mul_one]
    rw [kernel.fst_apply' _ _ MeasurableSet.univ]
    exact tendsto_integral_mLimsup_of_monotone le_rfl a s hs hs_iUnion hs_meas
  exact tendsto_nhds_unique h_integral h_integral'

end UnivFst

end DensityProcess

end ProbabilityTheory
