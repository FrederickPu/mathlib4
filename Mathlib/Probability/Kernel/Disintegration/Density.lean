/-
Copyright (c) 2024 Rémy Degenne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Rémy Degenne
-/
import Mathlib.Probability.Kernel.Composition
import Mathlib.Probability.Martingale.Convergence
import Mathlib.Analysis.SpecialFunctions.Log.Base
import Mathlib.Probability.Kernel.Disintegration.AuxLemmas

/-!
# Kernel density

Let `κ : kernel α (ℝ × β)` and `ν : kernel α ℝ` be two finite kernels with `kernel.fst κ ≤ ν`.
We build a function `f : α → ℝ → Set β → ℝ` jointly measurable in the first two arguments such that
for all `a : α` and all measurable sets `s : Set β` and `A : Set ℝ`,
`∫ t in A, f a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal`.

If we were interested only in a fixed `a : α`, then we could use the Radon-Nikodym derivative to
build the function `f`, as follows
```
def f_a (κ : kernel α (ℝ × β)) (ν : kernel a ℝ) (a : α) (t : ℝ) (s : Set β) : ℝ :=
  (((κ a).restrict (univ ×ˢ s)).fst.rnDeriv (ν a) t).toReal
```
However, we can't turn those functions for each `a` into a measurable function of the pair `(a, t)`.

In order to obtain measurability through countability, we discretize the real line.
For each `n : ℕ`, we define the intervals `I n k = [k * 2^-n, (k + 1) * 2^-n)` for `k : ℤ`.
For `t : ℝ`, let `indexI n t = ⌊t * 2^n⌋` be the integer such that `t ∈ I n (indexI n t)`.

For a given `n`, the function `densityProcess κ ν n : α → ℝ → Set β → ℝ` defined by
`fun a t s ↦ (κ a (I n (indexI n t) ×ˢ s) / ν a (I n (indexI n t))).toReal` has the desired
property that `∫ t in A, densityProcess κ ν n a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal` for all `A`
in the σ-algebra generated by the intervals `I n k` for `k : ℤ` and is measurable in `(a, t)`.

Let `ℱ` be the filtration of those σ-algebras for all `n : ℕ`. The functions `densityProcess κ ν n`
described here are a bounded `ν`-martingale for the filtration `ℱ`. By Doob's L1 martingale
convergence theorem, that martingale converges to a limit, which has a product-measurable version
and satisfies the integral equality for all `A` in `⨆ n, ℱ n = borel ℝ`. We have obtained the
desired density function.

## Main definitions

* `FooBar`

## Main statements

* `fooBar_unique`

## Implementation details


## References

The construction of the density process in this file follows the proof of Theorem 9.27 in
[O. Kallenberg, Foundations of modern probability][kallenberg2021].

TODO: adapted to use countably generated sigma-algebras.
-/

variable {α β : Type*} {mα : MeasurableSpace α}

open MeasureTheory Set Filter

open scoped NNReal ENNReal MeasureTheory Topology ProbabilityTheory

namespace ProbabilityTheory

lemma Measure.iInf_Iic_gt_prod {ρ : Measure (α × ℝ)} [IsFiniteMeasure ρ]
    {s : Set α} (hs : MeasurableSet s) (t : ℚ) :
    ⨅ r : { r' : ℚ // t < r' }, ρ (s ×ˢ Iic (r : ℝ)) = ρ (s ×ˢ Iic (t : ℝ)) := by
  rw [← measure_iInter_eq_iInf]
  · rw [← prod_iInter]
    congr with x : 1
    simp only [mem_iInter, mem_Iic, Subtype.forall, Subtype.coe_mk]
    refine' ⟨fun h => _, fun h a hta => h.trans _⟩
    · refine' le_of_forall_lt_rat_imp_le fun q htq => h q _
      exact mod_cast htq
    · exact mod_cast hta.le
  · exact fun _ => hs.prod measurableSet_Iic
  · refine' Monotone.directed_ge fun r r' hrr' => prod_subset_prod_iff.mpr (Or.inl ⟨subset_rfl, _⟩)
    refine' Iic_subset_Iic.mpr _
    exact mod_cast hrr'
  · exact ⟨⟨t + 1, lt_add_one _⟩, measure_ne_top ρ _⟩

variable {α β γ : Type*} {mα : MeasurableSpace α} {mγ : MeasurableSpace γ}
  [MeasurableSpace.CountablyGenerated γ]

-- todo : `Filtration` should be renamed to `filtration`
def ℱ (γ : Type*) [m : MeasurableSpace γ] [MeasurableSpace.CountablyGenerated γ] :
    Filtration ℕ m where
  seq := fun n ↦ MeasurableSpace.generateFrom <| MeasurableSpace.countablePartition γ n
  mono' := monotone_nat_of_le_succ (MeasurableSpace.generateFrom_countablePartition_le_succ _)
  le' := MeasurableSpace.generateFrom_countablePartition_le γ

lemma measurableSet_ℱ_countablePartition (n : ℕ) {s : Set γ}
    (hs : s ∈ MeasurableSpace.countablePartition γ n) :
    MeasurableSet[ℱ γ n] s :=
  MeasurableSpace.measurableSet_generateFrom hs

lemma existsPartitionSet_mem (n : ℕ) (t : γ) :
    ∃ s, s ∈ MeasurableSpace.countablePartition γ n ∧ t ∈ s := by
  have h_univ := MeasurableSpace.sUnion_countablePartition γ n
  have h_mem_univ := mem_univ t
  rw [← h_univ] at h_mem_univ
  simpa only [mem_sUnion] using h_mem_univ

def partitionSet (n : ℕ) (t : γ) : Set γ :=
  (existsPartitionSet_mem n t).choose

lemma partitionSet_mem (n : ℕ) (t : γ) :
    partitionSet n t ∈ MeasurableSpace.countablePartition γ n :=
  (existsPartitionSet_mem n t).choose_spec.1

lemma mem_partitionSet (n : ℕ) (t : γ) : t ∈ partitionSet n t :=
  (existsPartitionSet_mem n t).choose_spec.2

lemma mem_countablePartition_iff (n : ℕ) (t : γ) {s : Set γ}
    (hs : s ∈ MeasurableSpace.countablePartition γ n) :
    t ∈ s ↔ partitionSet n t = s := by
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · by_contra h_ne
    have h_disj : Disjoint s (partitionSet n t) :=
      MeasurableSpace.disjoint_countablePartition n hs (partitionSet_mem n t) (Ne.symm h_ne)
    refine absurd h_disj ?_
    rw [not_disjoint_iff_nonempty_inter]
    exact ⟨t, h, mem_partitionSet n t⟩
  · rw [← h]
    exact mem_partitionSet n t

lemma partitionSet_of_mem {n : ℕ} {t : γ} {s : Set γ}
    (hs : s ∈ MeasurableSpace.countablePartition γ n) (ht : t ∈ s) :
    partitionSet n t = s := by
  rwa [← mem_countablePartition_iff n t hs]

lemma measurableSet_ℱ_partitionSet (n : ℕ) (t : γ) :
    MeasurableSet[ℱ γ n] (partitionSet n t) :=
  measurableSet_ℱ_countablePartition n (partitionSet_mem n t)

lemma measurableSet_partitionSet (n : ℕ) (t : γ) :
    MeasurableSet (partitionSet n t) :=
  (ℱ γ).le n _ (measurableSet_ℱ_partitionSet n t)

instance todo_move (n : ℕ) : Countable (MeasurableSpace.countablePartition γ n) :=
  Set.Finite.countable (MeasurableSpace.finite_countablePartition _ _)

lemma measurable_aux (n : ℕ) (m : MeasurableSpace (MeasurableSpace.countablePartition γ n)) :
    @Measurable γ (MeasurableSpace.countablePartition γ n) (ℱ γ n) m
      (fun c : γ ↦ ⟨partitionSet n c, partitionSet_mem n c⟩) := by
  refine @measurable_to_countable' (MeasurableSpace.countablePartition γ n) γ m _
    (ℱ γ n) _ (fun t ↦ ?_)
  rcases t with ⟨t, ht⟩
  suffices MeasurableSet[ℱ γ n] {x | partitionSet n x = t} by
    convert this
    ext x
    simp
  have : {x | partitionSet n x = t} = t := by
    ext x
    rw [mem_setOf_eq, mem_countablePartition_iff n x ht]
  rw [this]
  exact measurableSet_ℱ_countablePartition _ ht

lemma measurable_partitionSet (n : ℕ) : Measurable[ℱ γ n] (partitionSet n) := by
  have : partitionSet n = (fun s : MeasurableSpace.countablePartition γ n ↦ (s : Set γ))
      ∘ (fun t ↦ ⟨partitionSet n t, partitionSet_mem n t⟩) := rfl
  rw [this]
  refine Measurable.comp
    (?_ : Measurable (fun s : MeasurableSpace.countablePartition γ n ↦ (s : Set γ))) ?_
  · measurability
  exact measurable_aux _ _

lemma MeasurableSpace.generateFrom_iSup {ι : Type*} (s : ι → Set (Set α)) :
    MeasurableSpace.generateFrom (⋃ i, s i) = ⨆ i, MeasurableSpace.generateFrom (s i) :=
  (@MeasurableSpace.giGenerateFrom α).gc.l_iSup

lemma iSup_ℱ (β : Type*) [m : MeasurableSpace β] [MeasurableSpace.CountablyGenerated β] :
    ⨆ n, ℱ β n = m := by
  conv_rhs => rw [← MeasurableSpace.generateFrom_iUnion_countablePartition β]
  rw [MeasurableSpace.generateFrom_iSup]
  rfl

variable [MeasurableSpace β]

section DensityProcess

variable {κ : kernel α (γ × β)} {ν : kernel α γ}

noncomputable
def densityProcess (κ : kernel α (γ × β)) (ν : kernel α γ) (n : ℕ) (a : α) (t : γ) (s : Set β) :
    ℝ :=
  (κ a (partitionSet n t ×ˢ s) / ν a (partitionSet n t)).toReal

lemma densityProcess_def (κ : kernel α (γ × β)) (ν : kernel α γ) (n : ℕ) (a : α) (s : Set β) :
    (fun t ↦ densityProcess κ ν n a t s)
      = fun t ↦ (κ a (partitionSet n t ×ˢ s) / ν a (partitionSet n t)).toReal :=
  rfl

lemma measurable_densityProcess_ℱ_aux (κ : kernel α (γ × β)) (ν : kernel α γ) (n : ℕ)
    {s : Set β} (hs : MeasurableSet s) :
    Measurable[MeasurableSpace.prod mα (ℱ γ n)] (fun (p : α × γ) ↦
      κ p.1 (partitionSet n p.2 ×ˢ s) / ν p.1 (partitionSet n p.2)) := by
  change Measurable[MeasurableSpace.prod mα (ℱ γ n)]
      ((fun (p : α × MeasurableSpace.countablePartition γ n) ↦ κ p.1 (↑p.2 ×ˢ s) / ν p.1 p.2)
        ∘ (fun (p : α × γ) ↦ (p.1, ⟨partitionSet n p.2, partitionSet_mem n p.2⟩)))
  have h1 : @Measurable _ _ (MeasurableSpace.prod mα ⊤) _
      (fun (p : α × MeasurableSpace.countablePartition γ n) ↦ κ p.1 (↑p.2 ×ˢ s) / ν p.1 p.2) := by
    refine Measurable.div ?_ ?_
    · refine measurable_from_prod_countable ?_
      rintro ⟨t, ht⟩
      simp only
      refine kernel.measurable_coe _ (MeasurableSet.prod ?_ hs)
      exact MeasurableSpace.measurableSet_countablePartition _ ht
    · refine measurable_from_prod_countable ?_
      rintro ⟨t, ht⟩
      simp only
      exact kernel.measurable_coe _ (MeasurableSpace.measurableSet_countablePartition _ ht)
  refine h1.comp ?_
  refine measurable_fst.prod_mk ?_
  change @Measurable (α × γ) (MeasurableSpace.countablePartition γ n)
    (MeasurableSpace.prod mα (ℱ γ n)) ⊤
    ((fun c : γ ↦ ⟨partitionSet n c, partitionSet_mem n c⟩) ∘ (fun p : α × γ ↦ p.2))
  refine Measurable.comp ?_ measurable_snd
  exact measurable_aux n ⊤

lemma measurable_densityProcess_aux (κ : kernel α (γ × β)) (ν : kernel α γ) (n : ℕ)
    {s : Set β} (hs : MeasurableSet s) :
    Measurable (fun (p : α × γ) ↦
      κ p.1 (partitionSet n p.2 ×ˢ s) / ν p.1 (partitionSet n p.2)) := by
  refine Measurable.mono (measurable_densityProcess_ℱ_aux κ ν n hs) ?_ le_rfl
  exact sup_le_sup le_rfl (MeasurableSpace.comap_mono ((ℱ γ).le _))

lemma measurable_densityProcess (κ : kernel α (γ × β)) (ν : kernel α γ) (n : ℕ)
    {s : Set β} (hs : MeasurableSet s) :
    Measurable (fun (p : α × γ) ↦ densityProcess κ ν n p.1 p.2 s) :=
  (measurable_densityProcess_aux κ ν n hs).ennreal_toReal

lemma measurable_densityProcess_left (κ : kernel α (γ × β)) (ν : kernel α γ) (n : ℕ)
    (t : γ) {s : Set β} (hs : MeasurableSet s) :
    Measurable (fun a ↦ densityProcess κ ν n a t s) :=
  (measurable_densityProcess κ ν n hs).comp (measurable_id.prod_mk measurable_const)

lemma measurable_densityProcess_right (κ : kernel α (γ × β)) (ν : kernel α γ) (n : ℕ)
    {s : Set β} (a : α) (hs : MeasurableSet s) :
    Measurable (fun t ↦ densityProcess κ ν n a t s) :=
  (measurable_densityProcess κ ν n hs).comp (measurable_const.prod_mk measurable_id)

lemma measurable_ℱ_densityProcess (κ : kernel α (γ × β)) (ν : kernel α γ) (n : ℕ)
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    Measurable[ℱ γ n] (fun t ↦ densityProcess κ ν n a t s) := by
  refine @Measurable.ennreal_toReal _ (ℱ γ n) _ ?_
  exact (measurable_densityProcess_ℱ_aux κ ν n hs).comp measurable_prod_mk_left

lemma stronglyMeasurable_ℱ_densityProcess (κ : kernel α (γ × β)) (ν : kernel α γ) (n : ℕ)
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    StronglyMeasurable[ℱ γ n] (fun t ↦ densityProcess κ ν n a t s) :=
  (measurable_ℱ_densityProcess κ ν n a hs).stronglyMeasurable

lemma adapted_densityProcess (κ : kernel α (γ × β)) (ν : kernel α γ) (a : α)
  {s : Set β} (hs : MeasurableSet s) :
    Adapted (ℱ γ) (fun n t ↦ densityProcess κ ν n a t s) :=
  fun n ↦ stronglyMeasurable_ℱ_densityProcess κ ν n a hs

lemma densityProcess_nonneg (κ : kernel α (γ × β)) (ν : kernel α γ) (n : ℕ)
    (a : α) (t : γ) (s : Set β) :
    0 ≤ densityProcess κ ν n a t s :=
  ENNReal.toReal_nonneg

lemma apply_partitionSet_le_of_fst_le (hκν : kernel.fst κ ≤ ν) (n : ℕ) (a : α) (t : γ) (s : Set β) :
    κ a (partitionSet n t ×ˢ s) ≤ ν a (partitionSet n t) := by
  calc κ a (partitionSet n t ×ˢ s)
    ≤ kernel.fst κ a (partitionSet n t) := by
        rw [kernel.fst_apply' _ _ (measurableSet_partitionSet _ _)]
        refine measure_mono (fun x ↦ ?_)
        simp only [mem_prod, mem_setOf_eq, and_imp]
        exact fun h _ ↦ h
  _ ≤ ν a (partitionSet n t) := hκν a _ (measurableSet_partitionSet _ _)

lemma densityProcess_le_one (hκν : kernel.fst κ ≤ ν) (n : ℕ) (a : α) (t : γ) (s : Set β) :
    densityProcess κ ν n a t s ≤ 1 := by
  refine ENNReal.toReal_le_of_le_ofReal zero_le_one (ENNReal.div_le_of_le_mul ?_)
  rw [ENNReal.ofReal_one, one_mul]
  exact apply_partitionSet_le_of_fst_le hκν n a t s

lemma snorm_densityProcess_le (hκν : kernel.fst κ ≤ ν) (n : ℕ) (a : α) (s : Set β) :
    snorm (fun t ↦ densityProcess κ ν n a t s) 1 (ν a) ≤ ν a univ := by
  refine (snorm_le_of_ae_bound (C := 1) (ae_of_all _ (fun x ↦ ?_))).trans ?_
  · simp only [Real.norm_eq_abs, abs_of_nonneg (densityProcess_nonneg κ ν n a x s),
      densityProcess_le_one hκν n a x s]
  · simp

lemma integrable_densityProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel ν] (n : ℕ)
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    Integrable (fun t ↦ densityProcess κ ν n a t s) (ν a) := by
  rw [← memℒp_one_iff_integrable]
  refine ⟨Measurable.aestronglyMeasurable ?_, ?_⟩
  · exact measurable_densityProcess_right κ ν n a hs
  · exact (snorm_densityProcess_le hκν n a s).trans_lt (measure_lt_top _ _)

lemma set_integral_densityProcess_I (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (n : ℕ) (a : α) {s : Set β} (hs : MeasurableSet s) {u : Set γ}
    (hu : u ∈ MeasurableSpace.countablePartition γ n) :
    ∫ t in u, densityProcess κ ν n a t s ∂(ν a) = (κ a (u ×ˢ s)).toReal := by
  have hu_meas : MeasurableSet u := MeasurableSpace.measurableSet_countablePartition n hu
  simp_rw [densityProcess]
  rw [integral_toReal]
  rotate_left
  · refine Measurable.aemeasurable ?_
    have h := measurable_densityProcess_aux κ ν n hs
    change Measurable ((fun (p : α × _) ↦ κ p.1 (partitionSet n p.2 ×ˢ s)
      / ν p.1 (partitionSet n p.2)) ∘ (fun t ↦ (a, t)))
    exact h.comp measurable_prod_mk_left
  · refine ae_of_all _ (fun t ↦ ?_)
    by_cases h0 : ν a (partitionSet n t) = 0
    · suffices κ a (partitionSet n t ×ˢ s) = 0 by simp [h0, this]
      have h0' : kernel.fst κ a (partitionSet n t) = 0 :=
        le_antisymm ((hκν a _ (measurableSet_partitionSet _ _)).trans h0.le) zero_le'
      rw [kernel.fst_apply' _ _ (measurableSet_partitionSet _ _)] at h0'
      refine measure_mono_null (fun x ↦ ?_) h0'
      simp only [mem_prod, mem_setOf_eq, and_imp]
      exact fun h _ ↦ h
    · refine ENNReal.div_lt_top ?_ h0
      exact measure_ne_top _ _
  congr
  have : ∫⁻ t in u, κ a (partitionSet n t ×ˢ s) / ν a (partitionSet n t) ∂(ν a)
      = ∫⁻ _ in u, κ a (u ×ˢ s) / ν a u ∂(ν a) := by
    refine set_lintegral_congr_fun hu_meas (ae_of_all _ (fun t ht ↦ ?_))
    rw [partitionSet_of_mem hu ht]
  rw [this]
  simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
  by_cases h0 : ν a u = 0
  · simp only [h0, mul_zero]
    have h0' : kernel.fst κ a u = 0 :=
      le_antisymm ((hκν a _ hu_meas).trans h0.le) zero_le'
    rw [kernel.fst_apply' _ _ hu_meas] at h0'
    refine (measure_mono_null ?_ h0').symm
    intro p
    simp only [mem_prod, mem_setOf_eq, and_imp]
    exact fun h _ ↦ h
  rw [div_eq_mul_inv, mul_assoc, ENNReal.inv_mul_cancel h0, mul_one]
  exact measure_ne_top _ _

lemma integral_densityProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (n : ℕ) (a : α) {s : Set β} (hs : MeasurableSet s) :
    ∫ t, densityProcess κ ν n a t s ∂(ν a) = (κ a (univ ×ˢ s)).toReal := by
  rw [← integral_univ, ← MeasurableSpace.sUnion_countablePartition γ n, sUnion_eq_iUnion,
    iUnion_prod_const, measure_iUnion]
  rotate_left
  · intro i j hij
    simp only [Set.disjoint_prod, disjoint_self, bot_eq_empty]
    refine Or.inl (MeasurableSpace.disjoint_countablePartition n i.prop j.prop ?_)
    rw [ne_eq, Subtype.coe_inj]
    exact hij
  · exact fun k ↦ (MeasurableSpace.measurableSet_countablePartition n k.prop).prod hs
  rw [integral_iUnion]
  rotate_left
  · exact fun k ↦ MeasurableSpace.measurableSet_countablePartition n k.prop
  · intro i j hij
    refine MeasurableSpace.disjoint_countablePartition n i.prop j.prop ?_
    rw [ne_eq, Subtype.coe_inj]
    exact hij
  · exact (integrable_densityProcess hκν n a hs).integrableOn
  rw [ENNReal.tsum_toReal_eq (fun _ ↦ measure_ne_top _ _)]
  congr with k
  rw [set_integral_densityProcess_I hκν _ _ hs k.prop]

lemma set_integral_densityProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (n : ℕ) (a : α) {s : Set β} (hs : MeasurableSet s) {A : Set γ} (hA : MeasurableSet[ℱ γ n] A) :
    ∫ t in A, densityProcess κ ν n a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal := by
  refine MeasurableSpace.induction_on_inter (m := ℱ γ n)
    (s := MeasurableSpace.countablePartition γ n)
    (C := fun A ↦ ∫ t in A, densityProcess κ ν n a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal) rfl
    ?_ ?_ ?_ ?_ ?_ hA
  · rintro s hs t ht hst
    suffices s = t by rwa [this, inter_self]
    by_contra h_ne
    rw [← not_disjoint_iff_nonempty_inter] at hst
    exact hst <| MeasurableSpace.disjoint_countablePartition n hs ht h_ne
  · simp
  · rintro u hu
    rw [set_integral_densityProcess_I hκν _ _ hs hu]
  · intro A hA hA_eq
    have hA' : MeasurableSet A := (ℱ γ).le _ _ hA
    have h := integral_add_compl hA' (integrable_densityProcess hκν n a hs)
    rw [hA_eq, integral_densityProcess hκν n a hs] at h
    have : Aᶜ ×ˢ s = univ ×ˢ s \ A ×ˢ s := by
      rw [prod_diff_prod, compl_eq_univ_diff]
      simp
    rw [this, measure_diff (by intro x; simp) (hA'.prod hs) (measure_ne_top (κ a) _),
      ENNReal.toReal_sub_of_le (measure_mono (by intro x; simp)) (measure_ne_top _ _)]
    rw [eq_tsub_iff_add_eq_of_le, add_comm]
    · exact h
    · rw [ENNReal.toReal_le_toReal (measure_ne_top _ _) (measure_ne_top _ _)]
      exact measure_mono (by intro x; simp)
  · intro f hf_disj hf h_eq
    rw [integral_iUnion (fun i ↦ (ℱ γ).le n _ (hf i)) hf_disj
      (integrable_densityProcess hκν _ _ hs).integrableOn]
    simp_rw [h_eq]
    rw [iUnion_prod_const, measure_iUnion _ (fun i ↦ ((ℱ γ).le n _ (hf i)).prod hs)]
    · rw [ENNReal.tsum_toReal_eq]
      exact fun _ ↦ measure_ne_top _ _
    · intro i j hij
      rw [Function.onFun, Set.disjoint_prod]
      exact Or.inl (hf_disj hij)

lemma set_integral_densityProcess_of_le (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] {n m : ℕ} (hnm : n ≤ m) (a : α) {s : Set β} (hs : MeasurableSet s)
    {A : Set γ} (hA : MeasurableSet[ℱ γ n] A) :
    ∫ t in A, densityProcess κ ν m a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal :=
  set_integral_densityProcess hκν m a hs ((ℱ γ).mono hnm A hA)

lemma condexp_densityProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    {i j : ℕ} (hij : i ≤ j) (a : α) {s : Set β} (hs : MeasurableSet s) :
    (ν a)[fun t ↦ densityProcess κ ν j a t s | ℱ γ i]
      =ᵐ[ν a] fun t ↦ densityProcess κ ν i a t s := by
  symm
  refine ae_eq_condexp_of_forall_set_integral_eq ?_ ?_ ?_ ?_ ?_
  · exact integrable_densityProcess hκν j a hs
  · refine fun t _ _ ↦ Integrable.integrableOn ?_
    exact integrable_densityProcess hκν _ _ hs
  · intro t ht _
    rw [set_integral_densityProcess hκν i a hs ht,
      set_integral_densityProcess_of_le hκν hij a hs ht]
  · exact StronglyMeasurable.aeStronglyMeasurable' (stronglyMeasurable_ℱ_densityProcess κ ν i a hs)

lemma martingale_densityProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    Martingale (fun n t ↦ densityProcess κ ν n a t s) (ℱ γ) (ν a) :=
  ⟨adapted_densityProcess κ ν a hs, fun _ _ h ↦ condexp_densityProcess hκν h a hs⟩

lemma densityProcess_mono_set (hκν : kernel.fst κ ≤ ν) (n : ℕ) (a : α) (t : γ)
    {s s' : Set β} (h : s ⊆ s') :
    densityProcess κ ν n a t s ≤ densityProcess κ ν n a t s' := by
  unfold densityProcess
  by_cases h0 : ν a (partitionSet n t) = 0
  · rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]
    simp
  have h_ne_top : ∀ s, κ a (partitionSet n t ×ˢ s) / ν a (partitionSet n t) ≠ ⊤ := by
    intro s
    rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    refine fun h_top ↦ eq_top_mono ?_ h_top
    exact apply_partitionSet_le_of_fst_le hκν n a t s
  rw [ENNReal.toReal_le_toReal]
  · gcongr
    rw [prod_subset_prod_iff]
    simp [subset_rfl, h]
  · exact h_ne_top s
  · exact h_ne_top s'

lemma densityProcess_mono_kernel_left {κ' : kernel α (γ × β)} (hκκ' : κ ≤ κ')
    (hκ'ν : kernel.fst κ' ≤ ν) (n : ℕ) (a : α) (t : γ) {s : Set β} (hs : MeasurableSet s) :
    densityProcess κ ν n a t s ≤ densityProcess κ' ν n a t s := by
  unfold densityProcess
  by_cases h0 : ν a (partitionSet n t) = 0
  · rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]
    simp
  have h_le : κ' a (partitionSet n t ×ˢ s)
      ≤ ν a (partitionSet n t) := apply_partitionSet_le_of_fst_le hκ'ν n a t s
  rw [ENNReal.toReal_le_toReal]
  · gcongr
    exact hκκ' _ _ ((measurableSet_partitionSet _ _).prod hs)
  · rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    refine fun h_top ↦ eq_top_mono ?_ h_top
    exact (hκκ' _ _ ((measurableSet_partitionSet _ _).prod hs)).trans h_le
  · rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    exact fun h_top ↦ eq_top_mono h_le h_top

lemma densityProcess_antitone_kernel_right {ν' : kernel α γ}
    (hνν' : ν ≤ ν') (hκν : kernel.fst κ ≤ ν) (n : ℕ) (a : α) (t : γ) (s : Set β) :
    densityProcess κ ν' n a t s ≤ densityProcess κ ν n a t s := by
  unfold densityProcess
  have h_le : κ a (partitionSet n t ×ˢ s)
      ≤ ν a (partitionSet n t) := apply_partitionSet_le_of_fst_le hκν n a t s
  by_cases h0 : ν a (partitionSet n t) = 0
  · suffices κ a (partitionSet n t ×ˢ s) = 0 by
      simp only [this, ENNReal.zero_div, ENNReal.zero_toReal, h0, le_refl]
    exact le_antisymm (h_le.trans h0.le) zero_le'
  have h0' : ν' a (partitionSet n t) ≠ 0 := by
    refine fun h ↦ h0 (le_antisymm (le_trans ?_ h.le) zero_le')
    exact hνν' _ _ (measurableSet_partitionSet _ _)
  rw [ENNReal.toReal_le_toReal]
  · gcongr
    exact hνν' _ _ (measurableSet_partitionSet _ _)
  · simp only [ne_eq, ENNReal.div_eq_top, h0', and_false, false_or, not_and, not_not]
    refine fun h_top ↦ eq_top_mono ?_ h_top
    exact h_le.trans (hνν' _ _ (measurableSet_partitionSet _ _))
  · simp only [ne_eq, ENNReal.div_eq_top, h0, and_false, false_or, not_and, not_not]
    exact fun h_top ↦ eq_top_mono h_le h_top

lemma densityProcess_empty (κ : kernel α (γ × β)) (ν : kernel α γ) (n : ℕ) (a : α) (t : γ) :
    densityProcess κ ν n a t ∅ = 0 := by
  simp [densityProcess]

lemma tendsto_densityProcess_atTop_empty_of_antitone (κ : kernel α (γ × β)) (ν : kernel α γ)
    [IsFiniteKernel κ] (n : ℕ) (a : α) (t : γ)
    (s : ℕ → Set β) (hs : Antitone s) (hs_iInter : ⋂ i, s i = ∅)
    (hs_meas : ∀ n, MeasurableSet (s n)) :
    Tendsto (fun m ↦ densityProcess κ ν n a t (s m)) atTop (𝓝 (densityProcess κ ν n a t ∅)) := by
  simp_rw [densityProcess]
  by_cases h0 : ν a (partitionSet n t) = 0
  · simp_rw [h0, ENNReal.toReal_div]
    simp
  refine (ENNReal.tendsto_toReal ?_).comp ?_
  · rw [ne_eq, ENNReal.div_eq_top]
    push_neg
    simp
  refine ENNReal.Tendsto.div_const ?_ ?_
  · have h := tendsto_measure_iInter (μ := κ a)
      (s := fun m ↦ partitionSet n t ×ˢ s m) ?_ ?_ ?_
    · convert h
      rw [← prod_iInter, hs_iInter]
    · exact fun n ↦ MeasurableSet.prod (measurableSet_partitionSet _ _) (hs_meas n)
    · intro m m' hmm'
      simp only [le_eq_subset, prod_subset_prod_iff, subset_rfl, true_and]
      exact Or.inl <| hs hmm'
    · exact ⟨0, measure_ne_top _ _⟩
  · simp only [prod_empty, OuterMeasure.empty', ne_eq, not_true_eq_false, false_or, h0,
      not_false_iff]

lemma tendsto_densityProcess_atTop_of_antitone (κ : kernel α (γ × β)) (ν : kernel α γ)
    [IsFiniteKernel κ] (n : ℕ) (a : α) (t : γ)
    (s : ℕ → Set β) (hs : Antitone s) (hs_iInter : ⋂ i, s i = ∅)
    (hs_meas : ∀ n, MeasurableSet (s n)) :
    Tendsto (fun m ↦ densityProcess κ ν n a t (s m)) atTop (𝓝 0) := by
  rw [← densityProcess_empty κ ν n a t]
  exact tendsto_densityProcess_atTop_empty_of_antitone κ ν n a t s hs hs_iInter hs_meas

lemma tendsto_densityProcess_limitProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] (a : α) {s : Set β} (hs : MeasurableSet s) :
    ∀ᵐ t ∂(ν a), Tendsto (fun n ↦ densityProcess κ ν n a t s) atTop
      (𝓝 ((ℱ γ).limitProcess (fun n t ↦ densityProcess κ ν n a t s) (ν a) t)) := by
  refine Submartingale.ae_tendsto_limitProcess (martingale_densityProcess hκν a hs).submartingale
    (R := (ν a univ).toNNReal) (fun n ↦ ?_)
  refine (snorm_densityProcess_le hκν n a s).trans_eq ?_
  rw [ENNReal.coe_toNNReal]
  exact measure_ne_top _ _

lemma limitProcess_mem_L1 (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    Memℒp ((ℱ γ).limitProcess (fun n t ↦ densityProcess κ ν n a t s) (ν a)) 1 (ν a) := by
  refine Submartingale.memℒp_limitProcess (martingale_densityProcess hκν a hs).submartingale
    (R := (ν a univ).toNNReal) (fun n ↦ ?_)
  refine (snorm_densityProcess_le hκν n a s).trans_eq ?_
  rw [ENNReal.coe_toNNReal]
  exact measure_ne_top _ _

lemma tendsto_snorm_one_densityProcess_limitProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] (a : α) {s : Set β} (hs : MeasurableSet s) :
    Tendsto (fun n ↦ snorm ((fun t ↦ densityProcess κ ν n a t s)
        - (ℱ γ).limitProcess (fun n t ↦ densityProcess κ ν n a t s) (ν a)) 1 (ν a))
      atTop (𝓝 0) := by
  refine Submartingale.tendsto_snorm_one_limitProcess ?_ ?_
  · exact (martingale_densityProcess hκν a hs).submartingale
  · refine uniformIntegrable_of le_rfl ENNReal.one_ne_top ?_ ?_
    · exact fun n ↦ (measurable_densityProcess_right κ ν n a hs).aestronglyMeasurable
    · intro ε _
      refine ⟨2, fun n ↦ ?_⟩
      refine le_of_eq_of_le ?_ (?_ : 0 ≤ ENNReal.ofReal ε)
      · have : {x | 2 ≤ ‖densityProcess κ ν n a x s‖₊} = ∅ := by
          ext x
          simp only [mem_setOf_eq, mem_empty_iff_false, iff_false, not_le]
          refine (?_ : _ ≤ (1 : ℝ≥0)).trans_lt one_lt_two
          rw [Real.nnnorm_of_nonneg (densityProcess_nonneg _ _ _ _ _ _)]
          exact mod_cast (densityProcess_le_one hκν _ _ _ _)
        rw [this]
        simp
      · simp

lemma tendsto_snorm_one_restrict_densityProcess_limitProcess [IsFiniteKernel κ] [IsFiniteKernel ν]
    (hκν : kernel.fst κ ≤ ν) (a : α) {s : Set β} (hs : MeasurableSet s) (A : Set γ) :
    Tendsto (fun n ↦ snorm ((fun t ↦ densityProcess κ ν n a t s)
        - (ℱ γ).limitProcess (fun n t ↦ densityProcess κ ν n a t s) (ν a)) 1 ((ν a).restrict A))
      atTop (𝓝 0) :=
  tendsto_snorm_restrict_zero (tendsto_snorm_one_densityProcess_limitProcess hκν a hs) A

noncomputable
def MLimsup (κ : kernel α (γ × β)) (ν : kernel α γ) (a : α) (t : γ) (s : Set β) : ℝ :=
  limsup (fun n ↦ densityProcess κ ν n a t s) atTop

lemma mLimsup_ae_eq_limitProcess (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    (fun t ↦ MLimsup κ ν a t s)
      =ᵐ[ν a] (ℱ γ).limitProcess (fun n t ↦ densityProcess κ ν n a t s) (ν a) := by
  filter_upwards [tendsto_densityProcess_limitProcess hκν a hs] with t ht using ht.limsup_eq

lemma tendsto_m_mLimsup (hκν : kernel.fst κ ≤ ν) (a : α) [IsFiniteKernel κ] [IsFiniteKernel ν]
    {s : Set β} (hs : MeasurableSet s) :
    ∀ᵐ t ∂(ν a),
      Tendsto (fun n ↦ densityProcess κ ν n a t s) atTop (𝓝 (MLimsup κ ν a t s)) := by
  filter_upwards [tendsto_densityProcess_limitProcess hκν a hs, mLimsup_ae_eq_limitProcess hκν a hs]
    with t h1 h2 using h2 ▸ h1

lemma measurable_mLimsup (κ : kernel α (γ × β)) (ν : kernel α γ)
    {s : Set β} (hs : MeasurableSet s) :
    Measurable (fun (p : α × γ) ↦ MLimsup κ ν p.1 p.2 s) :=
  measurable_limsup (fun n ↦ measurable_densityProcess κ ν n hs)

lemma measurable_mLimsup_left (κ : kernel α (γ × β)) (ν : kernel α γ) (t : γ)
    {s : Set β} (hs : MeasurableSet s) :
    Measurable (fun a ↦ MLimsup κ ν a t s) := by
  change Measurable ((fun (p : α × γ) ↦ MLimsup κ ν p.1 p.2 s) ∘ (fun a ↦ (a, t)))
  exact (measurable_mLimsup κ ν hs).comp measurable_prod_mk_right

lemma measurable_mLimsup_right (κ : kernel α (γ × β)) (ν : kernel α γ)
    {s : Set β} (hs : MeasurableSet s) (a : α) :
    Measurable (fun t ↦ MLimsup κ ν a t s) := by
  change Measurable ((fun (p : α × γ) ↦ MLimsup κ ν p.1 p.2 s) ∘ (fun t ↦ (a, t)))
  exact (measurable_mLimsup κ ν hs).comp measurable_prod_mk_left

lemma mLimsup_mono_set (hκν : kernel.fst κ ≤ ν) (a : α) (t : γ) {s s' : Set β} (h : s ⊆ s') :
    MLimsup κ ν a t s ≤ MLimsup κ ν a t s' := by
  refine limsup_le_limsup ?_ ?_ ?_
  · exact eventually_of_forall (fun n ↦ densityProcess_mono_set hκν n a t h)
  · exact isCoboundedUnder_le_of_le atTop (fun i ↦ densityProcess_nonneg _ _ _ _ _ _)
  · exact isBoundedUnder_of ⟨1, fun n ↦ densityProcess_le_one hκν _ _ _ _⟩

lemma mLimsup_nonneg (hκν : kernel.fst κ ≤ ν) (a : α) (t : γ) (s : Set β) :
    0 ≤ MLimsup κ ν a t s := by
  refine le_limsup_of_frequently_le ?_ ?_
  · exact frequently_of_forall (fun n ↦ densityProcess_nonneg _ _ _ _ _ _)
  · exact isBoundedUnder_of ⟨1, fun n ↦ densityProcess_le_one hκν _ _ _ _⟩

lemma mLimsup_le_one (hκν : kernel.fst κ ≤ ν) (a : α) (t : γ) (s : Set β) :
    MLimsup κ ν a t s ≤ 1 := by
  refine limsup_le_of_le ?_ ?_
  · exact isCoboundedUnder_le_of_le atTop (fun i ↦ densityProcess_nonneg _ _ _ _ _ _)
  · exact eventually_of_forall (fun n ↦ densityProcess_le_one hκν _ _ _ _)

lemma snorm_mLimsup_le (hκν : kernel.fst κ ≤ ν) (a : α) (s : Set β) :
    snorm (fun t ↦ MLimsup κ ν a t s) 1 (ν a) ≤ ν a univ := by
  refine (snorm_le_of_ae_bound (C := 1) (ae_of_all _ (fun t ↦ ?_))).trans ?_
  · simp only [Real.norm_eq_abs, abs_of_nonneg (mLimsup_nonneg hκν a t s),
      mLimsup_le_one hκν a t s]
  · simp

lemma integrable_mLimsup (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    Integrable (fun t ↦ MLimsup κ ν a t s) (ν a) := by
  rw [← memℒp_one_iff_integrable]
  refine ⟨Measurable.aestronglyMeasurable ?_, ?_⟩
  · exact measurable_mLimsup_right κ ν hs a
  · exact (snorm_mLimsup_le hκν a s).trans_lt (measure_lt_top _ _)

lemma tendsto_set_integral_m (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) (A : Set γ) :
    Tendsto (fun i ↦ ∫ x in A, densityProcess κ ν i a x s ∂(ν a)) atTop
      (𝓝 (∫ x in A, MLimsup κ ν a x s ∂(ν a))) := by
  refine tendsto_set_integral_of_L1' (μ := ν a) (fun t ↦ MLimsup κ ν a t s)
    (integrable_mLimsup hκν a hs) (F := fun i t ↦ densityProcess κ ν i a t s) (l := atTop)
    (eventually_of_forall (fun n ↦ integrable_densityProcess hκν _ _ hs)) ?_ A
  refine (tendsto_congr fun n ↦ ?_).mp (tendsto_snorm_one_densityProcess_limitProcess hκν a hs)
  refine snorm_congr_ae ?_
  exact EventuallyEq.rfl.sub (mLimsup_ae_eq_limitProcess hκν a hs).symm

/-- Auxiliary lemma for `set_integral_mLimsup`. -/
lemma set_integral_mLimsup_of_measurableSet (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν]
    (n : ℕ) (a : α) {s : Set β} (hs : MeasurableSet s) {A : Set γ} (hA : MeasurableSet[ℱ γ n] A) :
    ∫ t in A, MLimsup κ ν a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal := by
  suffices ∫ t in A, MLimsup κ ν a t s ∂(ν a) = ∫ t in A, densityProcess κ ν n a t s ∂(ν a) by
    rw [this]
    exact set_integral_densityProcess hκν _ _ hs hA
  suffices ∫ t in A, MLimsup κ ν a t s ∂(ν a)
      = limsup (fun i ↦ ∫ t in A, densityProcess κ ν i a t s ∂(ν a)) atTop by
    rw [this, ← limsup_const (α := ℕ) (f := atTop) (∫ t in A, densityProcess κ ν n a t s ∂(ν a)),
      limsup_congr]
    simp only [eventually_atTop, ge_iff_le]
    refine ⟨n, fun m hnm ↦ ?_⟩
    rw [set_integral_densityProcess_of_le hκν hnm _ hs hA,
      set_integral_densityProcess hκν _ _ hs hA]
  -- use L1 convergence
  have h := tendsto_set_integral_m hκν a hs A
  rw [h.limsup_eq]

lemma integral_mLimsup (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) :
    ∫ t, MLimsup κ ν a t s ∂(ν a) = (κ a (univ ×ˢ s)).toReal := by
  rw [← integral_univ, set_integral_mLimsup_of_measurableSet hκν 0 a hs MeasurableSet.univ]

lemma set_integral_mLimsup (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ] [IsFiniteKernel ν]
    (a : α) {s : Set β} (hs : MeasurableSet s) {A : Set γ} (hA : MeasurableSet A) :
    ∫ t in A, MLimsup κ ν a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal := by
  have hA' : MeasurableSet[⨆ n, ℱ γ n] A := by rwa [iSup_ℱ]
  refine MeasurableSpace.induction_on_inter (m := ⨆ n, ℱ γ n)
    (C := fun A ↦ ∫ t in A, MLimsup κ ν a t s ∂(ν a) = (κ a (A ×ˢ s)).toReal)
    (MeasurableSpace.measurableSpace_iSup_eq (ℱ γ)) ?_ ?_ ?_ ?_ ?_ hA'
  · rintro s ⟨n, hs⟩ t ⟨m, ht⟩ _
    exact ⟨max n m, ((ℱ γ).mono (le_max_left n m) _ hs).inter ((ℱ γ).mono (le_max_right n m) _ ht)⟩
  · simp
  · intro A ⟨n, hA⟩
    exact set_integral_mLimsup_of_measurableSet hκν n a hs hA
  · intro A hA hA_eq
    rw [iSup_ℱ] at hA
    have h := integral_add_compl hA (integrable_mLimsup hκν a hs)
    rw [hA_eq, integral_mLimsup hκν a hs] at h
    have : Aᶜ ×ˢ s = univ ×ˢ s \ A ×ˢ s := by
      rw [prod_diff_prod, compl_eq_univ_diff]
      simp
    rw [this, measure_diff (by intro x; simp) (hA.prod hs) (measure_ne_top (κ a) _),
      ENNReal.toReal_sub_of_le (measure_mono (by intro x; simp)) (measure_ne_top _ _)]
    rw [eq_tsub_iff_add_eq_of_le, add_comm]
    · exact h
    · rw [ENNReal.toReal_le_toReal (measure_ne_top _ _) (measure_ne_top _ _)]
      exact measure_mono (by intro x; simp)
  · intro f hf_disj hf h_eq
    rw [integral_iUnion _ hf_disj (integrable_mLimsup hκν _ hs).integrableOn]
    · simp_rw [h_eq]
      rw [← ENNReal.tsum_toReal_eq (fun _ ↦ measure_ne_top _ _)]
      congr
      rw [iUnion_prod_const, measure_iUnion]
      · intro i j hij
        rw [Function.onFun, Set.disjoint_prod]
        exact Or.inl (hf_disj hij)
      · rw [iSup_ℱ] at hf
        exact fun i ↦ (hf i).prod hs
    · rwa [iSup_ℱ] at hf

lemma tendsto_integral_mLimsup_of_monotone (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν]
    (a : α) (s : ℕ → Set β) (hs : Monotone s) (hs_iUnion : ⋃ i, s i = univ)
    (hs_meas : ∀ n, MeasurableSet (s n)) :
    Tendsto (fun m ↦ ∫ t, MLimsup κ ν a t (s m) ∂(ν a)) atTop (𝓝 (κ a univ).toReal) := by
  simp_rw [integral_mLimsup hκν a (hs_meas _)]
  have h_cont := ENNReal.continuousOn_toReal.continuousAt (x := κ a univ) ?_
  swap
  · rw [mem_nhds_iff]
    refine ⟨Iio (κ a univ + 1), fun x hx ↦ ne_top_of_lt (?_ : x < κ a univ + 1), isOpen_Iio, ?_⟩
    · simpa using hx
    · simp only [mem_Iio]
      exact ENNReal.lt_add_right (measure_ne_top _ _) one_ne_zero
  refine h_cont.tendsto.comp ?_
  have h := tendsto_measure_iUnion (s := fun n ↦ univ ×ˢ s n) (μ := κ a) ?_
  swap; · intro n m hnm x; simp only [mem_prod, mem_univ, true_and]; exact fun h ↦ hs hnm h
  convert h
  rw [← prod_iUnion, hs_iUnion]
  simp only [univ_prod_univ, measure_univ]

lemma tendsto_integral_mLimsup_of_antitone (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν]
    (a : α) (s : ℕ → Set β) (hs : Antitone s) (hs_iInter : ⋂ i, s i = ∅)
    (hs_meas : ∀ n, MeasurableSet (s n)) :
    Tendsto (fun m ↦ ∫ t, MLimsup κ ν a t (s m) ∂(ν a)) atTop (𝓝 0) := by
  simp_rw [integral_mLimsup hκν a (hs_meas _)]
  rw [← ENNReal.zero_toReal]
  have h_cont := ENNReal.continuousOn_toReal.continuousAt (x := 0) ?_
  swap
  · rw [mem_nhds_iff]
    refine ⟨Iio 1, fun x hx ↦ ne_top_of_lt (?_ : x < 1), isOpen_Iio, ?_⟩
    · simpa using hx
    · simp
  refine h_cont.tendsto.comp ?_
  have h := tendsto_measure_iInter (s := fun n ↦ univ ×ˢ s n) (μ := κ a)
    (fun n ↦ MeasurableSet.univ.prod (hs_meas n)) ?_ ?_
  rotate_left
  · intro n m hnm x; simp only [mem_prod, mem_univ, true_and]; exact fun h ↦ hs hnm h
  · refine ⟨0, measure_ne_top _ _⟩
  convert h
  rw [← prod_iInter, hs_iInter]
  simp only [ne_eq, prod_empty, OuterMeasure.empty', forall_exists_index]

lemma tendsto_mLimsup_atTop_ae_of_antitone (hκν : kernel.fst κ ≤ ν) [IsFiniteKernel κ]
    [IsFiniteKernel ν] (a : α) (s : ℕ → Set β) (hs : Antitone s) (hs_iInter : ⋂ i, s i = ∅)
    (hs_meas : ∀ n, MeasurableSet (s n)) :
    ∀ᵐ t ∂(ν a), Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 0) := by
  have h_anti : ∀ t, Antitone (fun m ↦ MLimsup κ ν a t (s m)) :=
    fun t n m hnm ↦ mLimsup_mono_set hκν a t (hs hnm)
  have h_le_one : ∀ m t, MLimsup κ ν a t (s m) ≤ 1 := fun m t ↦ mLimsup_le_one hκν a t (s m)
  -- for all `t`, `fun m ↦ MLimsup κ a (s m) t` has a limit
  have h_exists : ∀ t, ∃ l, Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 l) := by
    intro t
    have h_tendsto : Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop atBot ∨
        ∃ l, Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 l) :=
      tendsto_of_antitone (h_anti t)
    cases' h_tendsto with h_absurd h_tendsto
    · rw [tendsto_atTop_atBot_iff_of_antitone (h_anti t)] at h_absurd
      obtain ⟨r, hr⟩ := h_absurd (-1)
      have h_nonneg := mLimsup_nonneg hκν a t (s r)
      linarith
    · exact h_tendsto
  -- let `F` be the pointwise limit of `fun m ↦ MLimsup κ a (s m) t` for all `t`
  let F : γ → ℝ := fun t ↦ (h_exists t).choose
  have hF_tendsto : ∀ t, Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 (F t)) :=
    fun t ↦ (h_exists t).choose_spec
  have hF_nonneg : ∀ t, 0 ≤ F t :=
    fun t ↦ ge_of_tendsto' (hF_tendsto t) (fun m ↦ mLimsup_nonneg hκν a t (s m))
  have hF_le_one : ∀ t, F t ≤ 1 := fun t ↦ le_of_tendsto' (hF_tendsto t) (fun m ↦ h_le_one m t)
  have hF_int : Integrable F (ν a) := by
    rw [← memℒp_one_iff_integrable]
    refine ⟨?_, ?_⟩
    · refine aestronglyMeasurable_of_tendsto_ae atTop (fun n ↦ ?_) (ae_of_all _ hF_tendsto)
      exact (measurable_mLimsup_right κ ν (hs_meas _) a).aestronglyMeasurable
    · rw [snorm_one_eq_lintegral_nnnorm]
      calc ∫⁻ x, ‖F x‖₊ ∂(ν a) ≤ ∫⁻ _, 1 ∂(ν a) := by
            refine lintegral_mono (fun x ↦ ?_)
            rw [← ofReal_norm_eq_coe_nnnorm, Real.norm_eq_abs, ENNReal.ofReal_le_one,
              abs_of_nonneg (hF_nonneg _)]
            exact hF_le_one _
      _ < ⊤ := by
            simp only [lintegral_const, one_mul]
            exact measure_lt_top _ _
   -- it suffices to show that the limit `F` is 0 a.e.
  suffices ∀ᵐ t ∂(ν a), F t = 0 by
    filter_upwards [this] with t ht_eq
    rw [← ht_eq]
    exact hF_tendsto t
  -- since `F` is nonnegative, proving that its integral is 0 is sufficient to get that
  -- `F` is 0 a.e.
  suffices ∀ᵐ (t : γ) ∂(ν a), 0 = F t by filter_upwards [this] with a ha; simp [ha]
  refine ae_eq_of_integral_eq_of_ae_le (integrable_const _) hF_int  (ae_of_all _ hF_nonneg) ?_
  have h_integral :
      Tendsto (fun m : ℕ ↦ ∫ t, MLimsup κ ν a t (s m) ∂(ν a)) atTop (𝓝 (∫ t, F t ∂(ν a))) := by
    refine integral_tendsto_of_tendsto_of_antitone ?_ hF_int ?_ ?_
    · exact fun n ↦ integrable_mLimsup hκν _ (hs_meas n)
    · exact ae_of_all _ h_anti
    · exact ae_of_all _ hF_tendsto
  have h_integral' :
      Tendsto (fun m : ℕ ↦ ∫ t, MLimsup κ ν a t (s m) ∂(ν a)) atTop (𝓝 (∫ _, 0 ∂(ν a))) := by
    simp only [integral_zero]
    exact tendsto_integral_mLimsup_of_antitone hκν a s hs hs_iInter hs_meas
  exact (tendsto_nhds_unique h_integral h_integral').symm

section UnivFst

lemma densityProcess_univ [IsFiniteKernel κ] (n : ℕ) (a : α) (t : γ) :
    densityProcess κ (kernel.fst κ) n a t univ
      = if kernel.fst κ a (partitionSet n t) = 0 then 0 else 1 := by
  rw [densityProcess]
  by_cases h : kernel.fst κ a (partitionSet n t) = 0
  · simp [h]
    by_cases h' : κ a (partitionSet n t ×ˢ univ) = 0
    · simp [h']
    · rw [ENNReal.div_zero h']
      simp
  · simp only [h, ite_false]
    rw [kernel.fst_apply' _ _ (measurableSet_partitionSet _ _)]
    have : partitionSet n t ×ˢ univ = {p : γ × β | p.1 ∈ partitionSet n t} := by
      ext x
      simp
    rw [this, ENNReal.div_self]
    · simp
    · rwa [kernel.fst_apply' _ _ (measurableSet_partitionSet _ _)] at h
    · exact measure_ne_top _ _

lemma densityProcess_univ_ae (κ : kernel α (γ × β)) [IsFiniteKernel κ] (n : ℕ) (a : α) :
    ∀ᵐ t ∂(kernel.fst κ a), densityProcess κ (kernel.fst κ) n a t univ = 1 := by
  rw [ae_iff]
  have : {t | ¬ densityProcess κ (kernel.fst κ) n a t univ = 1}
      ⊆ {t | kernel.fst κ a (partitionSet n t) = 0} := by
    intro t ht
    simp only [mem_setOf_eq] at ht ⊢
    rw [densityProcess_univ] at ht
    simpa using ht
  refine measure_mono_null this ?_
  have : {t | kernel.fst κ a (partitionSet n t) = 0}
      ⊆ ⋃ (u) (_ : u ∈ MeasurableSpace.countablePartition γ n) (_ : kernel.fst κ a u = 0), u := by
    intro t ht
    simp only [mem_setOf_eq, mem_iUnion, exists_prop] at ht ⊢
    exact ⟨partitionSet n t, partitionSet_mem _ _, ht, mem_partitionSet _ _⟩
  refine measure_mono_null this ?_
  rw [measure_biUnion]
  · simp
  · exact (MeasurableSpace.finite_countablePartition _ _).countable
  · intro s hs t ht hst
    simp only [disjoint_iUnion_right, disjoint_iUnion_left]
    exact fun _ _ ↦ MeasurableSpace.disjoint_countablePartition n hs ht hst
  · intro s hs
    by_cases h : kernel.fst κ a s = 0
    · simp [h, MeasurableSpace.measurableSet_countablePartition n hs]
    · simp [h]

lemma tendsto_densityProcess_atTop_univ_of_monotone (κ : kernel α (γ × β))
    (n : ℕ) (a : α) (t : γ) (s : ℕ → Set β) (hs : Monotone s) (hs_iUnion : ⋃ i, s i = univ) :
    Tendsto (fun m ↦ densityProcess κ (kernel.fst κ) n a t (s m)) atTop
      (𝓝 (densityProcess κ (kernel.fst κ) n a t univ)) := by
  simp_rw [densityProcess]
  refine (ENNReal.tendsto_toReal ?_).comp ?_
  · rw [ne_eq, ENNReal.div_eq_top]
    push_neg
    simp_rw [kernel.fst_apply' _ _ (measurableSet_partitionSet _ _)]
    constructor
    · refine fun h h0 ↦ h (measure_mono_null (fun x ↦ ?_) h0)
      simp only [mem_prod, mem_setOf_eq, and_imp]
      exact fun h _ ↦ h
    · refine fun h_top ↦ eq_top_mono (measure_mono (fun x ↦ ?_)) h_top
      simp only [mem_prod, mem_setOf_eq, and_imp]
      exact fun h _ ↦ h
  by_cases h0 : kernel.fst κ a (partitionSet n t) = 0
  · rw [kernel.fst_apply' _ _ (measurableSet_partitionSet _ _)] at h0 ⊢
    suffices ∀ m, κ a (partitionSet n t ×ˢ s m) = 0 by
      simp only [this, h0, ENNReal.zero_div, tendsto_const_nhds_iff]
      suffices κ a (partitionSet n t ×ˢ univ) = 0 by
        simp only [this, ENNReal.zero_div]
      convert h0
      ext x
      simp only [mem_prod, mem_univ, and_true, mem_setOf_eq]
    refine fun m ↦ measure_mono_null (fun x ↦ ?_) h0
    simp only [mem_prod, mem_setOf_eq, and_imp]
    exact fun h _ ↦ h
  refine ENNReal.Tendsto.div_const ?_ ?_
  · have h := tendsto_measure_iUnion (μ := κ a)
      (s := fun m ↦ partitionSet n t ×ˢ s m) ?_
    swap
    · intro m m' hmm'
      simp only [le_eq_subset, prod_subset_prod_iff, subset_rfl, true_and]
      exact Or.inl <| hs hmm'
    convert h
    rw [← prod_iUnion, hs_iUnion]
  · exact Or.inr h0

lemma tendsto_densityProcess_atTop_ae_of_monotone (κ : kernel α (γ × β)) [IsFiniteKernel κ]
    (n : ℕ) (a : α) (s : ℕ → Set β) (hs : Monotone s) (hs_iUnion : ⋃ i, s i = univ) :
    ∀ᵐ t ∂(kernel.fst κ a),
      Tendsto (fun m ↦ densityProcess κ (kernel.fst κ) n a t (s m)) atTop (𝓝 1) := by
  filter_upwards [densityProcess_univ_ae κ n a] with t ht
  rw [← ht]
  exact tendsto_densityProcess_atTop_univ_of_monotone κ n a t s hs hs_iUnion

lemma mLimsup_univ (κ : kernel α (γ × β)) [IsFiniteKernel κ] (a : α) :
    ∀ᵐ t ∂(kernel.fst κ a), MLimsup κ (kernel.fst κ) a t univ = 1 := by
  have h := fun n ↦ densityProcess_univ_ae κ n a
  rw [← ae_all_iff] at h
  filter_upwards [h] with t ht
  rw [MLimsup]
  simp [ht]

lemma tendsto_mLimsup_atTop_ae_of_monotone [IsFiniteKernel κ]
    (a : α) (s : ℕ → Set β) (hs : Monotone s) (hs_iUnion : ⋃ i, s i = univ)
    (hs_meas : ∀ n, MeasurableSet (s n)) :
    ∀ᵐ t ∂(kernel.fst κ a), Tendsto (fun m ↦ MLimsup κ (kernel.fst κ) a t (s m)) atTop (𝓝 1) := by
  let ν := kernel.fst κ
  have h_mono : ∀ t, Monotone (fun m ↦ MLimsup κ (kernel.fst κ) a t (s m)) :=
    fun t n m hnm ↦ mLimsup_mono_set le_rfl a t (hs hnm)
  have h_le_one : ∀ m t, MLimsup κ ν a t (s m) ≤ 1 := fun m t ↦ mLimsup_le_one le_rfl a t (s m)
  -- for all `t`, `fun m ↦ MLimsup κ a (s m) t` has a limit
  have h_exists : ∀ t, ∃ l, Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 l) := by
    intro t
    have h_tendsto : Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop atTop ∨
        ∃ l, Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 l) :=
      tendsto_of_monotone (h_mono t)
    cases' h_tendsto with h_absurd h_tendsto
    · rw [tendsto_atTop_atTop_iff_of_monotone (h_mono t)] at h_absurd
      obtain ⟨r, hr⟩ := h_absurd 2
      exact absurd (hr.trans (h_le_one r t)) one_lt_two.not_le
    · exact h_tendsto
  -- let `F` be the pointwise limit of `fun m ↦ MLimsup κ a (s m) t` for all `t`
  let F : γ → ℝ := fun t ↦ (h_exists t).choose
  have hF_tendsto : ∀ t, Tendsto (fun m ↦ MLimsup κ ν a t (s m)) atTop (𝓝 (F t)) :=
    fun t ↦ (h_exists t).choose_spec
  have hF_nonneg : ∀ t, 0 ≤ F t :=
    fun t ↦ ge_of_tendsto' (hF_tendsto t) (fun m ↦ mLimsup_nonneg le_rfl a t (s m))
  have hF_le_one : ∀ t, F t ≤ 1 := fun t ↦ le_of_tendsto' (hF_tendsto t) (fun m ↦ h_le_one m t)
  have hF_int : Integrable F (ν a) := by
    rw [← memℒp_one_iff_integrable]
    constructor
    · refine aestronglyMeasurable_of_tendsto_ae atTop (fun n ↦ ?_) (ae_of_all _ hF_tendsto)
      exact (measurable_mLimsup_right κ ν (hs_meas _) a).aestronglyMeasurable
    · rw [snorm_one_eq_lintegral_nnnorm]
      calc ∫⁻ x, ‖F x‖₊ ∂(ν a) ≤ ∫⁻ _, 1 ∂(ν a) := by
            refine lintegral_mono (fun x ↦ ?_)
            rw [← ofReal_norm_eq_coe_nnnorm, Real.norm_eq_abs, ENNReal.ofReal_le_one,
              abs_of_nonneg (hF_nonneg _)]
            exact hF_le_one _
      _ < ⊤ := by simp only [lintegral_const, measure_univ, one_mul, measure_lt_top]
   -- it suffices to show that the limit `F` is 1 a.e.
  suffices ∀ᵐ t ∂(ν a), F t = 1 by
    filter_upwards [this] with t ht_eq
    rw [← ht_eq]
    exact hF_tendsto t
  -- since `F` is at most 1, proving that its integral is the same as the integral of 1 will tell
  -- us that `F` is 1 a.e.
  refine ae_eq_of_integral_eq_of_ae_le hF_int (integrable_const _) (ae_of_all _ hF_le_one) ?_
  have h_integral :
      Tendsto (fun m : ℕ ↦ ∫ t, MLimsup κ ν a t (s m) ∂(ν a)) atTop (𝓝 (∫ t, F t ∂(ν a))) := by
    refine integral_tendsto_of_tendsto_of_monotone ?_ hF_int ?_ ?_
    · exact fun n ↦ integrable_mLimsup le_rfl _ (hs_meas n)
    · exact ae_of_all _ h_mono
    · exact ae_of_all _ hF_tendsto
  have h_integral' :
      Tendsto (fun m : ℕ ↦ ∫ t, MLimsup κ ν a t (s m) ∂(ν a)) atTop (𝓝 (∫ _, 1 ∂(ν a))) := by
    rw [integral_const]
    simp only [smul_eq_mul, mul_one]
    rw [kernel.fst_apply' _ _ MeasurableSet.univ]
    exact tendsto_integral_mLimsup_of_monotone le_rfl a s hs hs_iUnion hs_meas
  exact tendsto_nhds_unique h_integral h_integral'

end UnivFst

end DensityProcess

end ProbabilityTheory
