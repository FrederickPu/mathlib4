import Mathlib.Probability.Kernel.Disintegration
import Mathlib.Probability.Martingale.Convergence
import Mathlib.Probability.Kernel.BuildKernel

open MeasureTheory Set Filter

open scoped ENNReal MeasureTheory Topology ProbabilityTheory

namespace ProbabilityTheory

variable {Œ± Œ© : Type*} {mŒ± : MeasurableSpace Œ±}
  [MeasurableSpace Œ©] [StandardBorelSpace Œ©] [Nonempty Œ©]

lemma measurableSet_tendsto_nhds {Œ≤ Œ≥ Œπ : Type*} [MeasurableSpace Œ≤]
    [TopologicalSpace Œ≥] [PolishSpace Œ≥] [MeasurableSpace Œ≥]
    [hŒ≥ : OpensMeasurableSpace Œ≥] [Countable Œπ] {l : Filter Œπ}
    [l.IsCountablyGenerated] {f : Œπ ‚Üí Œ≤ ‚Üí Œ≥} (hf : ‚àÄ i, Measurable (f i)) (c : Œ≥) :
    MeasurableSet { x | Tendsto (fun n ‚Ü¶ f n x) l (ùìù c) } := sorry

lemma measurableSet_tendsto_fun {Œ≤ Œ≥ Œπ : Type*} [MeasurableSpace Œ≤]
    [TopologicalSpace Œ≥] [PolishSpace Œ≥] [MeasurableSpace Œ≥]
    [hŒ≥ : OpensMeasurableSpace Œ≥] [Countable Œπ] {l : Filter Œπ}
    [l.IsCountablyGenerated] {f : Œπ ‚Üí Œ≤ ‚Üí Œ≥} (hf : ‚àÄ i, Measurable (f i)) {g : Œ≤ ‚Üí Œ≥}
    (hg : Measurable g) :
    MeasurableSet { x | Tendsto (fun n ‚Ü¶ f n x) l (ùìù (g x)) } := by
  letI := upgradePolishSpace Œ≥
  have : { x | Tendsto (fun n ‚Ü¶ f n x) l (ùìù (g x)) }
      = { x | Tendsto (fun n ‚Ü¶ dist (f n x) (g x)) l (ùìù 0) } := by
    ext x
    simp only [mem_setOf_eq]
    rw [tendsto_iff_dist_tendsto_zero]
  rw [this]
  exact measurableSet_tendsto_nhds (fun n ‚Ü¶ (hf n).dist hg) 0

section Real

section dissection_system

def I (n : ‚Ñï) (k : ‚Ñ§) : Set ‚Ñù := Set.Ico (k * (2‚Åª¬π : ‚Ñù) ^ n) ((k + 1) * ((2 : ‚Ñù) ^ n)‚Åª¬π)

lemma measurableSet_I (n : ‚Ñï) (k : ‚Ñ§) : MeasurableSet (I n k) := measurableSet_Ico

lemma pairwise_disjoint_I (n : ‚Ñï) : Pairwise (Disjoint on fun k ‚Ü¶ I n k) := by
  sorry

lemma I_succ_union (n : ‚Ñï) (k : ‚Ñ§) : I (n+1) (2 * k) ‚à™ I (n+1) (2 * k + 1) = I n k := by
  ext x
  cases lt_or_le x ((2 * k + 1) * ((2 : ‚Ñù) ^ (n+1))‚Åª¬π) with
  | inl h=>
    simp only [I, inv_pow, mem_Ico, Int.cast_mul, Int.int_cast_ofNat, Int.cast_add,
      Int.cast_one, mem_union, h, and_true, not_le.mpr h, false_and, or_false]
    sorry
  | inr h =>
    simp only [I, inv_pow, mem_Ico, Int.cast_mul, Int.int_cast_ofNat, Int.cast_add,
      Int.cast_one, mem_union, not_lt.mpr h, and_false, h, true_and, false_or]
    sorry

-- todo : `Filtration` should be renamed to `filtration`
def ‚Ñ± : Filtration ‚Ñï (borel ‚Ñù) where
  seq := fun n ‚Ü¶ MeasurableSpace.generateFrom {s | ‚àÉ k, s = I n k}
  mono' := by
    refine monotone_nat_of_le_succ ?_
    intro n
    refine MeasurableSpace.generateFrom_le fun s ‚ü®k, hs‚ü© ‚Ü¶ ?_
    rw [hs, ‚Üê I_succ_union n k]
    refine MeasurableSet.union ?_ ?_
    ¬∑ exact MeasurableSpace.measurableSet_generateFrom ‚ü®2 * k, rfl‚ü©
    ¬∑ exact MeasurableSpace.measurableSet_generateFrom ‚ü®2 * k + 1, rfl‚ü©
  le' := fun n ‚Ü¶ by
    refine MeasurableSpace.generateFrom_le fun s ‚ü®k, hs‚ü© ‚Ü¶ ?_
    rw [hs]
    exact measurableSet_I n k

lemma measurableSet_‚Ñ±_I (n : ‚Ñï) (k : ‚Ñ§) : MeasurableSet[‚Ñ± n] (I n k) :=
  MeasurableSpace.measurableSet_generateFrom ‚ü®k, rfl‚ü©

noncomputable def indexI (n : ‚Ñï) (t : ‚Ñù) : ‚Ñ§ := Int.floor (t * 2^n)

lemma mem_I_indexI (n : ‚Ñï) (t : ‚Ñù) : t ‚àà I n (indexI n t) := by
  rw [indexI, I]
  simp only [inv_pow, mem_Ico]
  constructor
  ¬∑ rw [‚Üê div_eq_mul_inv, div_le_iff]
    ¬∑ exact Int.floor_le (t * 2 ^ n)
    ¬∑ positivity
  ¬∑ rw [‚Üê div_eq_mul_inv, lt_div_iff]
    ¬∑ exact Int.lt_floor_add_one (t * 2 ^ n)
    ¬∑ positivity

lemma indexI_of_mem (n : ‚Ñï) (k : ‚Ñ§) (t : ‚Ñù) (ht : t ‚àà I n k) : indexI n t = k := by
  rw [indexI]
  simp only [I, inv_pow, mem_Ico, ‚Üê div_eq_mul_inv] at ht
  rw [div_le_iff, lt_div_iff] at ht
  ¬∑ rw [Int.floor_eq_iff]
    exact ht
  ¬∑ positivity
  ¬∑ positivity

lemma mem_I_iff_indexI (n : ‚Ñï) (k : ‚Ñ§) (t : ‚Ñù) : t ‚àà I n k ‚Üî indexI n t = k :=
  ‚ü®fun h ‚Ü¶ indexI_of_mem n k t h, fun h ‚Ü¶ h ‚ñ∏ mem_I_indexI n t‚ü©

lemma measurable_indexI (n : ‚Ñï) : Measurable[‚Ñ± n] (indexI n) := by
  unfold indexI
  refine @measurable_to_countable' ‚Ñ§ ‚Ñù _ _ (‚Ñ± n) _ (fun k ‚Ü¶ ?_)
  have : (fun t ‚Ü¶ ‚åät * (2 : ‚Ñù) ^ n‚åã) ‚Åª¬π' {k} = I n k := by
    ext t
    simp only [mem_preimage, mem_singleton_iff, I, inv_pow, mem_Ico]
    rw [Int.floor_eq_iff]
    refine ‚ü®fun ‚ü®h1, h2‚ü© ‚Ü¶ ‚ü®?_, ?_‚ü©, fun ‚ü®h1, h2‚ü© ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü©
    ¬∑ rw [mul_inv_le_iff, mul_comm]
      ¬∑ exact h1
      ¬∑ positivity
    ¬∑ rw [‚Üê div_eq_mul_inv, lt_div_iff]
      ¬∑ exact h2
      ¬∑ positivity
    ¬∑ rw [mul_inv_le_iff, mul_comm] at h1
      ¬∑ exact h1
      ¬∑ positivity
    ¬∑ rw [‚Üê div_eq_mul_inv, lt_div_iff] at h2
      ¬∑ exact h2
      ¬∑ positivity
  rw [this]
  exact measurableSet_‚Ñ±_I n k

lemma iUnion_I (n : ‚Ñï) : ‚ãÉ k, I n k = univ := by
  ext x
  simp only [mem_iUnion, mem_univ, iff_true]
  exact ‚ü®indexI n x, mem_I_indexI n x‚ü©

lemma indexI_le_indexI_iff (n : ‚Ñï) (t x : ‚Ñù) :
    indexI n t ‚â§ indexI n x ‚Üî ‚åät * 2 ^ n‚åã * (2 ^ n)‚Åª¬π ‚â§ x := by
  simp only [indexI._eq_1]
  rw [‚Üê div_eq_mul_inv, div_le_iff, Int.le_floor]
  positivity

lemma iUnion_ge_I (n : ‚Ñï) (t : ‚Ñù) :
    ‚ãÉ (k) (_ : indexI n t ‚â§ k), I n k = Ici (‚åät * 2 ^ n‚åã * (2 ^ n)‚Åª¬π : ‚Ñù) := by
  ext x
  simp [mem_I_iff_indexI, indexI_le_indexI_iff]

lemma iInter_biUnion_I (x : ‚Ñù) : ‚ãÇ n, ‚ãÉ (k) (_ : indexI n x ‚â§ k), I n k = Ici x := by
  ext t
  simp [iUnion_ge_I]
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ sorry
  ¬∑ intro n
    refine le_trans ?_ h
    rw [‚Üê div_eq_mul_inv, div_le_iff]
    ¬∑ exact Int.floor_le (x * 2 ^ n)
    ¬∑ positivity

lemma iSup_‚Ñ± : ‚®Ü n, ‚Ñ± n = borel ‚Ñù := by
  refine le_antisymm ?_ ?_
  ¬∑ rw [iSup_le_iff]
    exact ‚Ñ±.le
  ¬∑ conv_lhs => rw [borel_eq_generateFrom_Ici ‚Ñù]
    refine MeasurableSpace.generateFrom_le (fun s ‚ü®x, hx‚ü© ‚Ü¶ ?_)
    rw [‚Üê hx, ‚Üê iInter_biUnion_I x]
    refine MeasurableSet.iInter (fun n ‚Ü¶ ?_)
    refine MeasurableSet.biUnion ?_ (fun k hk ‚Ü¶ ?_)
    ¬∑ sorry
    ¬∑ sorry

end dissection_system

variable {Œ≤ : Type*} [MeasurableSpace Œ≤]

-- issue with the following: joint measurability
--noncomputable
--def M' (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) (s : Set Œ≤) (n : ‚Ñï) (t : ‚Ñù) : ‚Ñù‚â•0‚àû :=
--  (((Œ∫ a).restrict (univ √óÀ¢ s)).fst.trim (‚Ñ±.le n)).rnDeriv (((kernel.fst Œ∫ a)).trim (‚Ñ±.le n)) t

noncomputable
def M (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) (s : Set Œ≤) (n : ‚Ñï) (t : ‚Ñù) : ‚Ñù :=
  (Œ∫ a (I n (indexI n t) √óÀ¢ s) / kernel.fst Œ∫ a (I n (indexI n t))).toReal

lemma m_def (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) (s : Set Œ≤) (n : ‚Ñï) :
    M Œ∫ a s n = fun t ‚Ü¶ (Œ∫ a (I n (indexI n t) √óÀ¢ s) / kernel.fst Œ∫ a (I n (indexI n t))).toReal :=
  rfl

lemma measurable_m_aux (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) {s : Set Œ≤} (hs : MeasurableSet s) (n : ‚Ñï) :
    Measurable (fun (p : Œ± √ó ‚Ñù) ‚Ü¶
      Œ∫ p.1 (I n (indexI n p.2) √óÀ¢ s) / kernel.fst Œ∫ p.1 (I n (indexI n p.2))) := by
  change Measurable ((fun (p : Œ± √ó ‚Ñ§) ‚Ü¶
    Œ∫ p.1 (I n p.2 √óÀ¢ s) / kernel.fst Œ∫ p.1 (I n p.2)) ‚àò (fun (p : Œ± √ó ‚Ñù) ‚Ü¶ (p.1, indexI n p.2)))
  have h1 : Measurable (fun (p : Œ± √ó ‚Ñ§) ‚Ü¶ Œ∫ p.1 (I n p.2 √óÀ¢ s) / kernel.fst Œ∫ p.1 (I n p.2)) := by
    refine Measurable.div ?_ ?_
    ¬∑ have h_swap : Measurable fun (p : ‚Ñ§ √ó Œ±) ‚Ü¶ Œ∫ p.2 (I n p.1 √óÀ¢ s) := by
        refine measurable_uncurry_of_continuous_of_measurable
          (u := fun k a ‚Ü¶ Œ∫ a (I n k √óÀ¢ s)) ?_ ?_
        ¬∑ exact fun _ ‚Ü¶ continuous_bot
        ¬∑ exact fun _ ‚Ü¶ kernel.measurable_coe _ ((measurableSet_I _ _).prod hs)
      change Measurable ((fun (p : ‚Ñ§ √ó Œ±) ‚Ü¶ Œ∫ p.2 (I n p.1 √óÀ¢ s)) ‚àò Prod.swap)
      exact h_swap.comp measurable_swap
    ¬∑ have h_swap : Measurable fun (p : ‚Ñ§ √ó Œ±) ‚Ü¶ kernel.fst Œ∫ p.2 (I n p.1) := by
        refine measurable_uncurry_of_continuous_of_measurable
          (u := fun k a ‚Ü¶ kernel.fst Œ∫ a (I n k)) ?_ ?_
        ¬∑ exact fun _ ‚Ü¶ continuous_bot
        ¬∑ exact fun _ ‚Ü¶ kernel.measurable_coe _ (measurableSet_I _ _)
      change Measurable ((fun (p : ‚Ñ§ √ó Œ±) ‚Ü¶ kernel.fst Œ∫ p.2 (I n p.1)) ‚àò Prod.swap)
      exact h_swap.comp measurable_swap
  refine h1.comp (measurable_fst.prod_mk ?_)
  exact (Measurable.mono (measurable_indexI n) (‚Ñ±.le n) le_rfl).comp measurable_snd

lemma measurable_m (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) {s : Set Œ≤} (hs : MeasurableSet s) (n : ‚Ñï) :
    Measurable (fun (p : Œ± √ó ‚Ñù) ‚Ü¶ M Œ∫ p.1 s n p.2) :=
  (measurable_m_aux Œ∫ hs n).ennreal_toReal

lemma measurable_m_left (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) {s : Set Œ≤} (hs : MeasurableSet s) (n : ‚Ñï) (t : ‚Ñù) :
    Measurable (fun a ‚Ü¶ M Œ∫ a s n t) :=
  (measurable_m Œ∫ hs n).comp (measurable_id.prod_mk measurable_const)

lemma measurable_m_right (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) {s : Set Œ≤} (a : Œ±) (hs : MeasurableSet s) (n : ‚Ñï) :
    Measurable (M Œ∫ a s n) :=
  (measurable_m Œ∫ hs n).comp (measurable_const.prod_mk measurable_id)

lemma adapted_m (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) (s : Set Œ≤) : Adapted ‚Ñ± (M Œ∫ a s) := by
  intro n
  rw [m_def]
  refine Measurable.stronglyMeasurable ?_
  refine @Measurable.ennreal_toReal _ (‚Ñ± n) _ ?_
  refine Measurable.div ?_ ?_
  ¬∑ change Measurable[‚Ñ± n] ((fun k ‚Ü¶ Œ∫ a (I n k √óÀ¢ s)) ‚àò (indexI n))
    refine Measurable.comp ?_ (measurable_indexI n)
    exact measurable_of_countable _
  ¬∑ change Measurable[‚Ñ± n] ((fun k ‚Ü¶ (kernel.fst Œ∫) a (I n k)) ‚àò (indexI n))
    refine Measurable.comp ?_ (measurable_indexI n)
    exact measurable_of_countable _

lemma m_nonneg (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) (s : Set Œ≤) (n : ‚Ñï) (t : ‚Ñù) :
    0 ‚â§ M Œ∫ a s n t :=
  ENNReal.toReal_nonneg

lemma m_le_one (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) (s : Set Œ≤) (n : ‚Ñï) (t : ‚Ñù) :
    M Œ∫ a s n t ‚â§ 1 := by
  rw [M]
  refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_
  rw [ENNReal.ofReal_one]
  refine ENNReal.div_le_of_le_mul ?_
  rw [one_mul, kernel.fst_apply' _ _ (measurableSet_I _ _)]
  refine measure_mono (fun x ‚Ü¶ ?_)
  simp only [mem_prod, mem_setOf_eq, and_imp]
  exact fun h _ ‚Ü¶ h

lemma snorm_m_le_one (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsMarkovKernel (kernel.fst Œ∫)]
    (a : Œ±) (s : Set Œ≤) (n : ‚Ñï) :
    snorm (M Œ∫ a s n) 1 (kernel.fst Œ∫ a) ‚â§ 1 := by
  refine (snorm_mono_real (g := fun _ ‚Ü¶ 1) ?_).trans ?_
  ¬∑ intro x
    simp only [Real.norm_eq_abs, abs_le]
    constructor
    ¬∑ have h := m_nonneg Œ∫ a s n x
      linarith
    ¬∑ exact m_le_one _ _ _ _ _
  ¬∑ by_cases h0 : kernel.fst Œ∫ a = 0
    ¬∑ simp [h0]
    ¬∑ rw [snorm_const _ one_ne_zero h0]
      simp

lemma integrable_m (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsMarkovKernel (kernel.fst Œ∫)]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) (n : ‚Ñï) :
    Integrable (M Œ∫ a s n) (kernel.fst Œ∫ a) := by
  rw [‚Üê mem‚Ñíp_one_iff_integrable]
  refine ‚ü®Measurable.aestronglyMeasurable ?_, ?_‚ü©
  ¬∑ exact measurable_m_right Œ∫ a hs n
  ¬∑ exact (snorm_m_le_one Œ∫ a s n).trans_lt ENNReal.one_lt_top

lemma set_integral_m_I (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsFiniteKernel (kernel.fst Œ∫)]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) (n : ‚Ñï) (k : ‚Ñ§) :
    ‚à´ t in I n k, M Œ∫ a s n t ‚àÇ(kernel.fst Œ∫ a) = (Œ∫ a (I n k √óÀ¢ s)).toReal := by
  simp_rw [M]
  rw [integral_toReal]
  rotate_left
  ¬∑ refine Measurable.aemeasurable ?_
    have h := measurable_m_aux Œ∫ hs n
    sorry
  ¬∑ sorry
  congr
  have : ‚à´‚Åª t in I n k, Œ∫ a (I n (indexI n t) √óÀ¢ s)
                        / kernel.fst Œ∫ a (I n (indexI n t)) ‚àÇ(kernel.fst Œ∫) a
      = ‚à´‚Åª t in I n k, Œ∫ a (I n k √óÀ¢ s) / kernel.fst Œ∫ a (I n k) ‚àÇ(kernel.fst Œ∫) a := by
    refine set_lintegral_congr_fun (measurableSet_I _ _) (ae_of_all _ (fun t ht ‚Ü¶ ?_))
    rw [indexI_of_mem _ _ _ ht]
  rw [this]
  simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
  by_cases h0 : kernel.fst Œ∫ a (I n k) = 0
  ¬∑ simp only [h0, mul_zero]
    rw [kernel.fst_apply' _ _ (measurableSet_I _ _)] at h0
    refine (measure_mono_null ?_ h0).symm
    intro p
    simp only [mem_prod, mem_setOf_eq, and_imp]
    exact fun h _ ‚Ü¶ h
  rw [div_eq_mul_inv, mul_assoc, ENNReal.inv_mul_cancel h0, mul_one]
  exact measure_ne_top _ _

lemma integral_m (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsMarkovKernel Œ∫]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) (n : ‚Ñï) :
    ‚à´ t, M Œ∫ a s n t ‚àÇ(kernel.fst Œ∫ a) = (Œ∫ a (univ √óÀ¢ s)).toReal := by
  rw [‚Üê integral_univ, ‚Üê iUnion_I n, iUnion_prod_const, measure_iUnion]
  rotate_left
  ¬∑ intro i j hij
    simp only [Set.disjoint_prod, disjoint_self, bot_eq_empty]
    exact Or.inl (pairwise_disjoint_I n hij)
  ¬∑ exact fun k ‚Ü¶ (measurableSet_I n k).prod hs
  rw [integral_iUnion (measurableSet_I n) (pairwise_disjoint_I n)
    (integrable_m Œ∫ a hs n).integrableOn]
  rw [ENNReal.tsum_toReal_eq (fun _ ‚Ü¶ measure_ne_top _ _)]
  congr with k
  rw [set_integral_m_I _ _ hs]

lemma set_integral_m (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsMarkovKernel Œ∫]
    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) (n : ‚Ñï) {A : Set ‚Ñù} (hA : MeasurableSet[‚Ñ± n] A) :
    ‚à´ t in A, M Œ∫ a s n t ‚àÇ(kernel.fst Œ∫ a) = (Œ∫ a (A √óÀ¢ s)).toReal := by
  suffices MeasurableSet A ‚àß ‚à´ t in A, M Œ∫ a s n t ‚àÇ(kernel.fst Œ∫ a) = (Œ∫ a (A √óÀ¢ s)).toReal by
    exact this.2
  refine MeasurableSpace.generateFrom_induction
    (p := fun A' ‚Ü¶ MeasurableSet A'
      ‚àß ‚à´ t in A', M Œ∫ a s n t ‚àÇ(kernel.fst Œ∫) a = ENNReal.toReal (Œ∫ a (A' √óÀ¢ s)))
    (C := {s | ‚àÉ k, s = I n k}) ?_ ?_ ?_ ?_ hA
  ¬∑ rintro _ ‚ü®k, rfl‚ü©
    rw [set_integral_m_I _ _ hs]
    exact ‚ü®measurableSet_I _ _, rfl‚ü©
  ¬∑ simp only [MeasurableSet.empty, Measure.restrict_empty, integral_zero_measure, empty_prod,
      OuterMeasure.empty', ENNReal.zero_toReal, and_self]
  ¬∑ intro A ‚ü®hA, hA_eq‚ü©
    have h := integral_add_compl hA (integrable_m Œ∫ a hs n)
    refine ‚ü®hA.compl, ?_‚ü©
    rw [hA_eq, integral_m Œ∫ a hs] at h
    have : A·∂ú √óÀ¢ s = univ √óÀ¢ s \ A √óÀ¢ s := by
      rw [prod_diff_prod, compl_eq_univ_diff]
      simp
    rw [this, measure_diff (by intro x; simp) (hA.prod hs) (measure_ne_top (Œ∫ a) _),
      ENNReal.toReal_sub_of_le (measure_mono (by intro x; simp)) (measure_ne_top _ _)]
    rw [eq_tsub_iff_add_eq_of_le, add_comm]
    ¬∑ exact h
    ¬∑ rw [ENNReal.toReal_le_toReal (measure_ne_top _ _) (measure_ne_top _ _)]
      exact measure_mono (by intro x; simp)
  ¬∑ intro f hf
    simp only at hf
    -- todo: introduce disjointed sets, etc.
    sorry

lemma condexp_m (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsMarkovKernel (kernel.fst Œ∫)] (a : Œ±) (s : Set Œ≤)
    {i j : ‚Ñï} (hij : i ‚â§ j) :
    (kernel.fst Œ∫ a)[M Œ∫ a s j | ‚Ñ± i] =·µê[kernel.fst Œ∫ a] M Œ∫ a s i := by
  sorry

lemma martingale_m (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsMarkovKernel (kernel.fst Œ∫)] (a : Œ±) (s : Set Œ≤) :
    Martingale (M Œ∫ a s) ‚Ñ± (kernel.fst Œ∫ a) :=
  ‚ü®adapted_m Œ∫ a s, fun _ _ ‚Ü¶ condexp_m Œ∫ a s‚ü©

lemma m_mono_set (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) {s s' : Set Œ≤} (h : s ‚äÜ s') (n : ‚Ñï) (t : ‚Ñù) :
    M Œ∫ a s n t ‚â§ M Œ∫ a s' n t := by
  rw [M, M, ENNReal.toReal_le_toReal]
  ¬∑ gcongr
    rw [prod_subset_prod_iff]
    simp [subset_rfl, h]
  ¬∑ rw [ne_eq, ENNReal.div_eq_top]
    push_neg
    constructor
    ¬∑ sorry
    ¬∑ sorry
  ¬∑ rw [ne_eq, ENNReal.div_eq_top]
    push_neg
    constructor
    ¬∑ sorry
    ¬∑ sorry

lemma m_univ (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsFiniteKernel Œ∫] (a : Œ±) (n : ‚Ñï) (t : ‚Ñù) :
    M Œ∫ a univ n t = if kernel.fst Œ∫ a (I n (indexI n t)) = 0 then 0 else 1 := by
  rw [M]
  by_cases h : kernel.fst Œ∫ a (I n (indexI n t)) = 0
  ¬∑ simp [h]
    by_cases h' : Œ∫ a (I n (indexI n t) √óÀ¢ univ) = 0
    ¬∑ simp [h']
    ¬∑ rw [ENNReal.div_zero h']
      simp
  ¬∑ simp only [h, ite_false]
    rw [kernel.fst_apply' _ _ (measurableSet_I _ _)]
    have : I n (indexI n t) √óÀ¢ univ = {p : ‚Ñù √ó Œ≤ | p.1 ‚àà I n (indexI n t)} := by
      ext x
      simp
    rw [this, ENNReal.div_self]
    ¬∑ simp
    ¬∑ rwa [kernel.fst_apply' _ _ (measurableSet_I _ _)] at h
    ¬∑ exact measure_ne_top _ _

lemma m_empty (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsFiniteKernel Œ∫] (a : Œ±) (n : ‚Ñï) (t : ‚Ñù) :
    M Œ∫ a ‚àÖ n t = 0 := by
  rw [M]
  simp

lemma m_univ_ae (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsFiniteKernel Œ∫] (a : Œ±) (n : ‚Ñï) :
    ‚àÄ·µê t ‚àÇ(kernel.fst Œ∫ a), M Œ∫ a univ n t = 1 := by
  rw [ae_iff]
  have : {t | ¬¨M Œ∫ a univ n t = 1} ‚äÜ {t | kernel.fst Œ∫ a (I n (indexI n t)) = 0} := by
    intro t ht
    simp only [mem_setOf_eq] at ht ‚ä¢
    rw [m_univ] at ht
    simpa using ht
  refine measure_mono_null this ?_
  have : {t | kernel.fst Œ∫ a (I n (indexI n t)) = 0}
      ‚äÜ ‚ãÉ (k) (_ : kernel.fst Œ∫ a (I n k) = 0), I n k := by
    intro t
    simp only [mem_setOf_eq, mem_iUnion, exists_prop]
    intro ht
    exact ‚ü®indexI n t, ht, mem_I_indexI _ _‚ü©
  refine measure_mono_null this ?_
  rw [measure_iUnion_null]
  intro i
  simp

lemma tendsto_m_atTop_univ_of_monotone (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsFiniteKernel Œ∫]
    (a : Œ±) (s : ‚Ñï ‚Üí Set Œ≤) (hs : Monotone s) (hs_iUnion : ‚ãÉ i, s i = univ) (n : ‚Ñï) (t : ‚Ñù) :
    Tendsto (fun m ‚Ü¶ M Œ∫ a (s m) n t) atTop (ùìù (M Œ∫ a univ n t)) := by
  simp_rw [M]
  refine (ENNReal.tendsto_toReal ?_).comp ?_
  ¬∑ rw [ne_eq, ENNReal.div_eq_top]
    push_neg
    sorry
  by_cases h0 : kernel.fst Œ∫ a (I n (indexI n t)) = 0
  ¬∑ simp only [h0]
    sorry
  refine ENNReal.Tendsto.div_const ?_ ?_
  ¬∑ have h := tendsto_measure_iUnion (Œº := Œ∫ a) (s := fun m ‚Ü¶ I n (indexI n t) √óÀ¢ s m) ?_
    swap
    ¬∑ intro m m' hmm'
      simp only [le_eq_subset, prod_subset_prod_iff, subset_rfl, true_and]
      exact Or.inl <| hs hmm'
    convert h
    rw [‚Üê prod_iUnion, hs_iUnion]
  ¬∑ exact Or.inr h0

lemma tendsto_m_atTop_ae_of_monotone (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsFiniteKernel Œ∫]
    (a : Œ±) (s : ‚Ñï ‚Üí Set Œ≤) (hs : Monotone s) (hs_iUnion : ‚ãÉ i, s i = univ) (n : ‚Ñï) :
    ‚àÄ·µê t ‚àÇ(kernel.fst Œ∫ a), Tendsto (fun m ‚Ü¶ M Œ∫ a (s m) n t) atTop (ùìù 1) := by
  filter_upwards [m_univ_ae Œ∫ a n] with t ht
  rw [‚Üê ht]
  exact tendsto_m_atTop_univ_of_monotone Œ∫ a s hs hs_iUnion n t

lemma tendsto_m_atTop_empty_of_antitone (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsFiniteKernel Œ∫]
    (a : Œ±) (s : ‚Ñï ‚Üí Set Œ≤) (hs : Antitone s) (hs_iInter : ‚ãÇ i, s i = ‚àÖ)
    (hs_meas : ‚àÄ n, MeasurableSet (s n)) (n : ‚Ñï) (t : ‚Ñù) :
    Tendsto (fun m ‚Ü¶ M Œ∫ a (s m) n t) atTop (ùìù (M Œ∫ a ‚àÖ n t)) := by
  simp_rw [M]
  refine (ENNReal.tendsto_toReal ?_).comp ?_
  ¬∑ rw [ne_eq, ENNReal.div_eq_top]
    push_neg
    sorry
  by_cases h0 : kernel.fst Œ∫ a (I n (indexI n t)) = 0
  ¬∑ simp only [h0, prod_empty, OuterMeasure.empty', ENNReal.zero_div]
    sorry
  refine ENNReal.Tendsto.div_const ?_ ?_
  ¬∑ have h := tendsto_measure_iInter (Œº := Œ∫ a) (s := fun m ‚Ü¶ I n (indexI n t) √óÀ¢ s m) ?_ ?_ ?_
    ¬∑ convert h
      rw [‚Üê prod_iInter, hs_iInter]
    ¬∑ exact fun n ‚Ü¶ MeasurableSet.prod (measurableSet_I _ _) (hs_meas n)
    ¬∑ intro m m' hmm'
      simp only [le_eq_subset, prod_subset_prod_iff, subset_rfl, true_and]
      exact Or.inl <| hs hmm'
    ¬∑ exact ‚ü®0, measure_ne_top _ _‚ü©
  ¬∑ simp only [prod_empty, OuterMeasure.empty', ne_eq, not_true_eq_false, false_or, h0,
      not_false_iff]

lemma tendsto_m_atTop_of_antitone (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsFiniteKernel Œ∫]
    (a : Œ±) (s : ‚Ñï ‚Üí Set Œ≤) (hs : Antitone s) (hs_iInter : ‚ãÇ i, s i = ‚àÖ)
    (hs_meas : ‚àÄ n, MeasurableSet (s n)) (n : ‚Ñï) (t : ‚Ñù) :
    Tendsto (fun m ‚Ü¶ M Œ∫ a (s m) n t) atTop (ùìù 0) := by
  rw [‚Üê m_empty Œ∫ a n t]
  exact tendsto_m_atTop_empty_of_antitone Œ∫ a s hs hs_iInter hs_meas n t

lemma tendsto_m_limitProcess (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) [IsMarkovKernel (kernel.fst Œ∫)]
    (s : Set Œ≤) :
    ‚àÄ·µê t ‚àÇ(kernel.fst Œ∫ a),
      Tendsto (fun n ‚Ü¶ M Œ∫ a s n t) atTop (ùìù (‚Ñ±.limitProcess (M Œ∫ a s) (kernel.fst Œ∫ a) t)) := by
  refine Submartingale.ae_tendsto_limitProcess (martingale_m Œ∫ a s).submartingale (R := 1) ?_
  intro n
  rw [ENNReal.coe_one]
  exact snorm_m_le_one Œ∫ a s n

lemma limitProcess_mem_L1 (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsMarkovKernel (kernel.fst Œ∫)]
    (a : Œ±) (s : Set Œ≤) :
    Mem‚Ñíp (‚Ñ±.limitProcess (M Œ∫ a s) (kernel.fst Œ∫ a)) 1 (kernel.fst Œ∫ a) := by
  refine Submartingale.mem‚Ñíp_limitProcess (martingale_m Œ∫ a s).submartingale (R := 1) ?_
  intro n
  rw [ENNReal.coe_one]
  exact snorm_m_le_one Œ∫ a s n

noncomputable
def MLimsup (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) (s : Set Œ≤) (t : ‚Ñù) : ‚Ñù :=
  limsup (fun n ‚Ü¶ M Œ∫ a s n t) atTop

lemma mLimsup_ae_eq_mLim (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsMarkovKernel (kernel.fst Œ∫)]
    (a : Œ±) (s : Set Œ≤) :
    MLimsup Œ∫ a s =·µê[kernel.fst Œ∫ a] ‚Ñ±.limitProcess (M Œ∫ a s) (kernel.fst Œ∫ a) := by
  filter_upwards [tendsto_m_limitProcess Œ∫ a s] with t ht using ht.limsup_eq

lemma tendsto_m_mLimsup (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) [IsMarkovKernel (kernel.fst Œ∫)] (s : Set Œ≤) :
    ‚àÄ·µê t ‚àÇ(kernel.fst Œ∫ a),
      Tendsto (fun n ‚Ü¶ M Œ∫ a s n t) atTop (ùìù (MLimsup Œ∫ a s t)) := by
  filter_upwards [tendsto_m_limitProcess Œ∫ a s, mLimsup_ae_eq_mLim Œ∫ a s] with t h1 h2
  rw [h2]
  exact h1

lemma measurable_mLimsup (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) {s : Set Œ≤} (hs : MeasurableSet s) :
    Measurable (fun (p : Œ± √ó ‚Ñù) ‚Ü¶ MLimsup Œ∫ p.1 s p.2) :=
  measurable_limsup (fun n ‚Ü¶ measurable_m Œ∫ hs n)

lemma measurable_mLimsup_left (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) {s : Set Œ≤} (hs : MeasurableSet s) (t : ‚Ñù) :
    Measurable (fun a ‚Ü¶ MLimsup Œ∫ a s t) := by
  sorry

lemma measurable_mLimsup_right (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) {s : Set Œ≤} (hs : MeasurableSet s) (a : Œ±) :
    Measurable (MLimsup Œ∫ a s) := by
  sorry

lemma mLimsup_mono_set (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) {s s' : Set Œ≤} (h : s ‚äÜ s') (t : ‚Ñù) :
    MLimsup Œ∫ a s t ‚â§ MLimsup Œ∫ a s' t := by
  rw [MLimsup, MLimsup]
  refine limsup_le_limsup ?_ ?_ ?_
  ¬∑ exact Filter.eventually_of_forall (fun n ‚Ü¶ m_mono_set Œ∫ a h n t)
  ¬∑ sorry
  ¬∑ sorry

lemma mLimsup_nonneg (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) (s : Set Œ≤) (t : ‚Ñù) :
    0 ‚â§ MLimsup Œ∫ a s t := by
  refine le_limsup_of_frequently_le ?_ ?_
  ¬∑ exact Filter.frequently_of_forall (fun n ‚Ü¶ m_nonneg _ _ _ _ _)
  ¬∑ sorry

lemma mLimsup_le_one (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) (a : Œ±) (s : Set Œ≤) (t : ‚Ñù) :
    MLimsup Œ∫ a s t ‚â§ 1 := by
  refine limsup_le_of_le ?_ ?_
  ¬∑ sorry
  ¬∑ exact Filter.eventually_of_forall (fun n ‚Ü¶ m_le_one _ _ _ _ _)

lemma mLimsup_univ (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsFiniteKernel Œ∫] (a : Œ±) :
    ‚àÄ·µê t ‚àÇ(kernel.fst Œ∫ a), MLimsup Œ∫ a Set.univ t = 1 := by
  have h := m_univ_ae Œ∫ a
  rw [‚Üê ae_all_iff] at h
  filter_upwards [h] with t ht
  rw [MLimsup]
  simp_rw [ht]
  rw [limsup_const] -- should be simp

lemma tendsto_mLimsup_atTop_ae_of_monotone (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsFiniteKernel Œ∫]
    (a : Œ±) (s : ‚Ñï ‚Üí Set Œ≤) (hs : Monotone s) (hs_iUnion : ‚ãÉ i, s i = univ) (n : ‚Ñï) :
    ‚àÄ·µê t ‚àÇ(kernel.fst Œ∫ a), Tendsto (fun m ‚Ü¶ MLimsup Œ∫ a (s m) t) atTop (ùìù 1) := by
  sorry

lemma tendsto_mLimsup_atTop_of_antitone (Œ∫ : kernel Œ± (‚Ñù √ó Œ≤)) [IsFiniteKernel Œ∫]
    (a : Œ±) (s : ‚Ñï ‚Üí Set Œ≤) (hs : Antitone s) (hs_iInter : ‚ãÇ i, s i = ‚àÖ)
    (hs_meas : ‚àÄ n, MeasurableSet (s n)) (n : ‚Ñï) (t : ‚Ñù) :
    Tendsto (fun m ‚Ü¶ MLimsup Œ∫ a (s m) t) atTop (ùìù 0) := by
  sorry

section Iic_Q

noncomputable
def todo1' (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (a : Œ±) (t : ‚Ñù) (q : ‚Ñö) : ‚Ñù := MLimsup Œ∫ a (Set.Iic q) t

lemma measurable_todo1' (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (q : ‚Ñö) :
    Measurable (fun p : Œ± √ó ‚Ñù ‚Ü¶ todo1' Œ∫ p.1 p.2 q) := by
  sorry

lemma monotone_todo1' (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (a : Œ±) (t : ‚Ñù) : Monotone (todo1' Œ∫ a t) := by
  intro q r hqr
  rw [todo1', todo1']
  refine mLimsup_mono_set Œ∫ a ?_ t
  refine Iic_subset_Iic.mpr ?_
  exact_mod_cast hqr

lemma todo1'_nonneg (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (a : Œ±) (t : ‚Ñù) (q : ‚Ñö) : 0 ‚â§ todo1' Œ∫ a t q :=
  mLimsup_nonneg Œ∫ a _ t

lemma todo1'_le_one (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (a : Œ±) (t : ‚Ñù) (q : ‚Ñö) : todo1' Œ∫ a t q ‚â§ 1 :=
  mLimsup_le_one Œ∫ a _ t

lemma tendsto_atTop_todo1' (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (a : Œ±) :
    ‚àÄ·µê t ‚àÇ(kernel.fst Œ∫ a), Tendsto (fun q ‚Ü¶ todo1' Œ∫ a t q) atTop (ùìù 1) := by
  sorry

lemma tendsto_atBot_todo1' (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (a : Œ±) (t : ‚Ñù) :
    Tendsto (fun q ‚Ü¶ todo1' Œ∫ a t q) atBot (ùìù 0) := by
  sorry

lemma iInf_rat_gt_todo1'_eq (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (a : Œ±) (t : ‚Ñù) (q : ‚Ñö) :
    ‚®Ö r : Ioi q, todo1' Œ∫ a t r = todo1' Œ∫ a t q := by
  sorry

end Iic_Q

section Rat

lemma measurableSet_tendstoAtTopSet (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) :
    MeasurableSet {p : Œ± √ó ‚Ñù | Tendsto (fun q ‚Ü¶ todo1' Œ∫ p.1 p.2 q) atTop (ùìù 1)} :=
  measurableSet_tendsto_nhds (fun q ‚Ü¶ measurable_todo1' Œ∫ q) 1

open Classical in
noncomputable
def todo2' (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (p : Œ± √ó ‚Ñù) : ‚Ñö ‚Üí ‚Ñù :=
  if Tendsto (fun q ‚Ü¶ todo1' Œ∫ p.1 p.2 q) atTop (ùìù 1)
    then fun q ‚Ü¶ todo1' Œ∫ p.1 p.2 q
    else fun q ‚Ü¶ if q < 0 then 0 else 1

lemma measurable_todo2' (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (q : ‚Ñö) :
    Measurable (fun p ‚Ü¶ todo2' Œ∫ p q) := by
  classical
  simp only [todo2', ite_apply]
  exact Measurable.ite (measurableSet_tendstoAtTopSet Œ∫) (measurable_todo1' Œ∫ q) measurable_const

lemma monotone_todo2' (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (p : Œ± √ó ‚Ñù) :
    Monotone (todo2' Œ∫ p) := by
  unfold todo2'
  split_ifs with h
  ¬∑ exact monotone_todo1' Œ∫ p.1 p.2
  ¬∑ intro x y hxy
    dsimp only
    split_ifs with h_1 h_2 h_2
    exacts [le_rfl, zero_le_one, absurd (hxy.trans_lt h_2) h_1, le_rfl]

lemma todo2'_nonneg (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (p : Œ± √ó ‚Ñù) :
    0 ‚â§ todo2' Œ∫ p := by
  unfold todo2'
  split_ifs with h
  ¬∑ exact todo1'_nonneg Œ∫ p.1 p.2
  ¬∑ intro q
    simp only [Pi.one_apply]
    split_ifs <;> simp

lemma todo2'_le_one (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (p : Œ± √ó ‚Ñù) :
    todo2' Œ∫ p ‚â§ 1 := by
  unfold todo2'
  split_ifs with h
  ¬∑ exact todo1'_le_one Œ∫ p.1 p.2
  ¬∑ intro q
    simp only [Pi.one_apply]
    split_ifs <;> simp

lemma tendsto_atTop_todo2' (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (p : Œ± √ó ‚Ñù) :
    Tendsto (todo2' Œ∫ p) atTop (ùìù 1) := by
  unfold todo2'
  split_ifs with h
  ¬∑ exact h
  ¬∑ refine' (tendsto_congr' _).mp tendsto_const_nhds
    rw [EventuallyEq, eventually_atTop]
    exact ‚ü®0, fun q hq ‚Ü¶ (if_neg (not_lt.mpr hq)).symm‚ü©

lemma tendsto_atBot_todo2' (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (p : Œ± √ó ‚Ñù) :
    Tendsto (todo2' Œ∫ p) atBot (ùìù 0) := by
  unfold todo2'
  split_ifs with h
  ¬∑ exact tendsto_atBot_todo1' Œ∫ p.1 p.2
  ¬∑ refine' (tendsto_congr' _).mp tendsto_const_nhds
    rw [EventuallyEq, eventually_atBot]
    refine' ‚ü®-1, fun q hq ‚Ü¶ (if_pos (hq.trans_lt _)).symm‚ü©
    linarith

theorem inf_gt_todo2' (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) (p : Œ± √ó ‚Ñù) (t : ‚Ñö) :
    ‚®Ö r : Ioi t, todo2' Œ∫ p r = todo2' Œ∫ p t := by
  rw [todo2']
  split_ifs with hp
  ¬∑ simp_rw [iInf_rat_gt_todo1'_eq]
  ¬∑ simp only
    have h_bdd : BddBelow (range fun r : ‚Ü•(Ioi t) ‚Ü¶ ite ((r : ‚Ñö) < 0) (0 : ‚Ñù) 1) := by
      refine' ‚ü®0, fun x hx ‚Ü¶ _‚ü©
      obtain ‚ü®y, rfl‚ü© := mem_range.mpr hx
      dsimp only
      split_ifs
      exacts [le_rfl, zero_le_one]
    split_ifs with h
    ¬∑ refine' le_antisymm _ (le_ciInf fun x ‚Ü¶ _)
      ¬∑ obtain ‚ü®q, htq, hq_neg‚ü© : ‚àÉ q, t < q ‚àß q < 0 := by
          refine' ‚ü®t / 2, _, _‚ü©
          ¬∑ linarith
          ¬∑ linarith
        refine' (ciInf_le h_bdd ‚ü®q, htq‚ü©).trans _
        rw [if_pos]
        rwa [Subtype.coe_mk]
      ¬∑ split_ifs
        exacts [le_rfl, zero_le_one]
    ¬∑ refine' le_antisymm _ _
      ¬∑ refine' (ciInf_le h_bdd ‚ü®t + 1, lt_add_one t‚ü©).trans _
        split_ifs
        exacts [zero_le_one, le_rfl]
      ¬∑ refine' le_ciInf fun x ‚Ü¶ _
        rw [if_neg]
        rw [not_lt] at h ‚ä¢
        exact h.trans (mem_Ioi.mp x.prop).le

lemma isCDFLike_todo2' (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) : IsCDFLike (todo2' Œ∫) where
  mono := monotone_todo2' Œ∫
  nonneg := todo2'_nonneg Œ∫
  le_one := todo2'_le_one Œ∫
  tendsto_atTop_one := tendsto_atTop_todo2' Œ∫
  tendsto_atBot_zero := tendsto_atBot_todo2' Œ∫
  iInf_rat_gt_eq := inf_gt_todo2' Œ∫
  measurable := measurable_todo2' Œ∫

end Rat

noncomputable
def kernel.condexpReal (Œ∫ : kernel Œ± (‚Ñù √ó ‚Ñù)) : kernel (Œ± √ó ‚Ñù) ‚Ñù :=
  (isCDFLike_todo2' Œ∫).kernel

end Real

variable {Œ©' : Type*} [MeasurableSpace Œ©'] [StandardBorelSpace Œ©'] [Nonempty Œ©']

def kernel.condexp (Œ∫ : kernel Œ± (Œ© √ó Œ©')) [IsMarkovKernel (kernel.fst Œ∫)] :
    kernel (Œ± √ó Œ©) Œ©' :=
  sorry

theorem kernel.eq_compProd (Œ∫ : kernel Œ± (Œ© √ó Œ©')) [IsMarkovKernel Œ∫] :
    Œ∫ = kernel.fst Œ∫ ‚äó‚Çñ (kernel.condexp Œ∫) := by
  sorry

end ProbabilityTheory
